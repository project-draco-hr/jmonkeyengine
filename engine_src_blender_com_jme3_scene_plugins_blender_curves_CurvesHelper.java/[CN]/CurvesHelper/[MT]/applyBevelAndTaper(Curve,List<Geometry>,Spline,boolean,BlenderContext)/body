{
  Vector3f[] curvePoints=BufferUtils.getVector3Array(curve.getFloatBuffer(Type.Position));
  float curveLength=curve.getLength();
  FloatBuffer[] vertexBuffers=new FloatBuffer[bevelObject.size()];
  FloatBuffer[] normalBuffers=new FloatBuffer[bevelObject.size()];
  IndexBuffer[] indexBuffers=new IndexBuffer[bevelObject.size()];
  for (int geomIndex=0; geomIndex < bevelObject.size(); ++geomIndex) {
    Mesh mesh=bevelObject.get(geomIndex).getMesh();
    Vector3f[] positions=BufferUtils.getVector3Array(mesh.getFloatBuffer(Type.Position));
    Vector3f[] bevelPoints=this.transformToFirstLineOfBevelPoints(positions,curvePoints[0],curvePoints[1]);
    List<Vector3f[]> bevels=new ArrayList<Vector3f[]>(curvePoints.length);
    bevels.add(bevelPoints);
    vertexBuffers[geomIndex]=BufferUtils.createFloatBuffer(bevelPoints.length * 3 * curvePoints.length* (smooth ? 1 : 6));
    for (int i=1; i < curvePoints.length - 1; ++i) {
      bevelPoints=this.transformBevel(bevelPoints,curvePoints[i - 1],curvePoints[i],curvePoints[i + 1]);
      bevels.add(bevelPoints);
    }
    bevelPoints=this.transformBevel(bevelPoints,curvePoints[curvePoints.length - 2],curvePoints[curvePoints.length - 1],null);
    bevels.add(bevelPoints);
    float lengthAlongCurve=0;
    for (int i=0; i < curvePoints.length; ++i) {
      if (i > 0) {
        lengthAlongCurve+=curvePoints[i].subtract(curvePoints[i - 1]).length();
      }
      float taperScale=this.getTaperScale(taperObject,i == 0 ? 0 : lengthAlongCurve / curveLength);
      this.applyScale(bevels.get(i),curvePoints[i],taperScale);
    }
    if (smooth) {
      for (      Vector3f[] bevel : bevels) {
        for (        Vector3f d : bevel) {
          vertexBuffers[geomIndex].put(d.x);
          vertexBuffers[geomIndex].put(d.y);
          vertexBuffers[geomIndex].put(d.z);
        }
      }
    }
 else {
      for (int i=0; i < curvePoints.length - 1; ++i) {
        for (int j=0; j < bevelPoints.length - 1; ++j) {
          vertexBuffers[geomIndex].put(bevels.get(i)[j].x);
          vertexBuffers[geomIndex].put(bevels.get(i)[j].y);
          vertexBuffers[geomIndex].put(bevels.get(i)[j].z);
          vertexBuffers[geomIndex].put(bevels.get(i)[j + 1].x);
          vertexBuffers[geomIndex].put(bevels.get(i)[j + 1].y);
          vertexBuffers[geomIndex].put(bevels.get(i)[j + 1].z);
          vertexBuffers[geomIndex].put(bevels.get(i + 1)[j].x);
          vertexBuffers[geomIndex].put(bevels.get(i + 1)[j].y);
          vertexBuffers[geomIndex].put(bevels.get(i + 1)[j].z);
          vertexBuffers[geomIndex].put(bevels.get(i)[j + 1].x);
          vertexBuffers[geomIndex].put(bevels.get(i)[j + 1].y);
          vertexBuffers[geomIndex].put(bevels.get(i)[j + 1].z);
          vertexBuffers[geomIndex].put(bevels.get(i + 1)[j + 1].x);
          vertexBuffers[geomIndex].put(bevels.get(i + 1)[j + 1].y);
          vertexBuffers[geomIndex].put(bevels.get(i + 1)[j + 1].z);
          vertexBuffers[geomIndex].put(bevels.get(i + 1)[j].x);
          vertexBuffers[geomIndex].put(bevels.get(i + 1)[j].y);
          vertexBuffers[geomIndex].put(bevels.get(i + 1)[j].z);
        }
      }
    }
    indexBuffers[geomIndex]=this.generateIndexes(bevelPoints.length,curvePoints.length,smooth);
    normalBuffers[geomIndex]=this.generateNormals(indexBuffers[geomIndex],vertexBuffers[geomIndex],smooth);
  }
  List<Geometry> result=new ArrayList<Geometry>(vertexBuffers.length);
  Float oneReferenceToCurveLength=new Float(curveLength);
  for (int i=0; i < vertexBuffers.length; ++i) {
    Mesh mesh=new Mesh();
    mesh.setBuffer(Type.Position,3,vertexBuffers[i]);
    if (indexBuffers[i].getBuffer() instanceof IntBuffer) {
      mesh.setBuffer(Type.Index,3,(IntBuffer)indexBuffers[i].getBuffer());
    }
 else {
      mesh.setBuffer(Type.Index,3,(ShortBuffer)indexBuffers[i].getBuffer());
    }
    mesh.setBuffer(Type.Normal,3,normalBuffers[i]);
    Geometry g=new Geometry("g" + i,mesh);
    g.setUserData("curveLength",oneReferenceToCurveLength);
    g.updateModelBound();
    result.add(g);
  }
  return result;
}
