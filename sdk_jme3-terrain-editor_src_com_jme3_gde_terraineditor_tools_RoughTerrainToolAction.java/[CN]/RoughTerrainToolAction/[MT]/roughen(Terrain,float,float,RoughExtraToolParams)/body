{
  Basis fractalFilter=createFractalGenerator(params,weight);
  List<Vector2f> locs=new ArrayList<Vector2f>();
  List<Float> heights=new ArrayList<Float>();
  int radiusStepsX=(int)(radius / ((Node)terrain).getLocalScale().x);
  int radiusStepsZ=(int)(radius / ((Node)terrain).getLocalScale().z);
  float xStepAmount=((Node)terrain).getLocalScale().x;
  float zStepAmount=((Node)terrain).getLocalScale().z;
  int r2=(int)(radius * 2);
  FloatBuffer fb=fractalFilter.getBuffer(worldLoc.x,worldLoc.z,0,r2);
  int xfb=0, yfb=0;
  for (int z=-radiusStepsZ; z < radiusStepsZ; z++) {
    for (int x=-radiusStepsX; x < radiusStepsX; x++) {
      float locX=worldLoc.x + (x * xStepAmount);
      float locZ=worldLoc.z + (z * zStepAmount);
      float height=fb.get(yfb * r2 + xfb);
      if (isInRadius(locX - worldLoc.x,locZ - worldLoc.z,radius)) {
        float h=calculateHeight(radius,height,locX - worldLoc.x,locZ - worldLoc.z);
        locs.add(new Vector2f(locX,locZ));
        heights.add(h);
      }
      xfb++;
    }
    yfb++;
    xfb=0;
  }
  undoLocs=locs;
  undoHeights=heights;
  terrain.adjustHeight(locs,heights);
  ((Node)terrain).updateModelBound();
}
