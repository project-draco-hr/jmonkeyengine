{
  GeometryList l=viewPort.getQueue().getShadowQueueContent(ShadowMode.Receive);
  matCache.clear();
  for (int i=0; i < l.size(); i++) {
    Material mat=l.get(i).getMaterial();
    if (mat.getMaterialDef().getTechniqueDef(postTechniqueName) != null) {
      if (!matCache.contains(mat)) {
        matCache.add(mat);
      }
    }
 else {
      needsfallBackMaterial=true;
    }
  }
  for (  Material mat : matCache) {
    if (mat.getParam("Splits") == null) {
      mat.setColor("Splits",splits);
    }
    if (mat.getParam("ShadowMapSize") == null) {
      mat.setFloat("ShadowMapSize",shadowMapSize);
    }
    for (int j=0; j < nbSplits; j++) {
      mat.setMatrix4("LightViewProjectionMatrix" + j,lightViewProjectionsMatrices[j]);
    }
    if (mat.getParam("ShadowMap0") == null) {
      for (int j=0; j < nbSplits; j++) {
        mat.setTexture("ShadowMap" + j,shadowMaps[j]);
      }
    }
    if (applyHWShadows || mat.getParam("HardwareShadows") == null) {
      mat.setBoolean("HardwareShadows",compareMode == CompareMode.Hardware);
      applyHWShadows=false;
    }
    if (applyFilterMode || mat.getParam("FilterMode") == null) {
      mat.setInt("FilterMode",filterMode.ordinal());
      applyFilterMode=false;
    }
    if (mat.getParam("PCFEdge") == null || applyPCFEdge) {
      mat.setFloat("PCFEdge",edgesThickness);
      applyPCFEdge=false;
    }
    if (mat.getParam("ShadowIntensity") == null || applyShadowIntensity) {
      mat.setFloat("ShadowIntensity",shadowIntensity);
      applyShadowIntensity=false;
    }
    if (fadeInfo != null && mat.getParam("FadeInfo") == null || applyFadeInfo) {
      mat.setVector2("FadeInfo",fadeInfo);
      applyFadeInfo=false;
    }
  }
  if (needsfallBackMaterial) {
    setPostShadowParams();
  }
}
