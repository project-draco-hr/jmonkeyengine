{
  bonesGroups[0]=0;
  Pointer pDvert=(Pointer)meshStructure.getFieldValue("dvert");
  FloatBuffer weightsFloatData=BufferUtils.createFloatBuffer(vertexListSize * MAXIMUM_WEIGHTS_PER_VERTEX);
  ByteBuffer indicesData=BufferUtils.createByteBuffer(vertexListSize * MAXIMUM_WEIGHTS_PER_VERTEX);
  if (pDvert.isNotNull()) {
    boolean warnAboutTooManyVertexWeights=false;
    List<Structure> dverts=pDvert.fetchData();
    int vertexIndex=0;
    TreeMap<Float,Integer> weightToIndexMap=new TreeMap<Float,Integer>();
    for (    Structure dvert : dverts) {
      List<Integer> vertexIndices=vertexReferenceMap.get(Integer.valueOf(vertexIndex));
      if (vertexIndices != null) {
        int totweight=((Number)dvert.getFieldValue("totweight")).intValue();
        Pointer pDW=(Pointer)dvert.getFieldValue("dw");
        if (totweight > 0 && groupToBoneIndexMap != null) {
          weightToIndexMap.clear();
          int weightIndex=0;
          List<Structure> dw=pDW.fetchData();
          for (          Structure deformWeight : dw) {
            Integer boneIndex=groupToBoneIndexMap.get(((Number)deformWeight.getFieldValue("def_nr")).intValue());
            float weight=((Number)deformWeight.getFieldValue("weight")).floatValue();
            if (boneIndex != null && (weight > 0.0f || weightIndex > 0)) {
              if (weightIndex < MAXIMUM_WEIGHTS_PER_VERTEX) {
                if (weight == 0.0f) {
                  boneIndex=Integer.valueOf(0);
                }
                for (                Integer index : vertexIndices) {
                  weightsFloatData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX + weightIndex,weight);
                  indicesData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX + weightIndex,boneIndex.byteValue());
                }
                weightToIndexMap.put(weight,weightIndex);
                bonesGroups[0]=Math.max(bonesGroups[0],weightIndex + 1);
              }
 else               if (weight > 0) {
                warnAboutTooManyVertexWeights=true;
                Entry<Float,Integer> lowestWeightAndIndex=weightToIndexMap.firstEntry();
                if (lowestWeightAndIndex != null && lowestWeightAndIndex.getKey() < weight) {
                  for (                  Integer index : vertexIndices) {
                    weightsFloatData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX + lowestWeightAndIndex.getValue(),weight);
                    indicesData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX + lowestWeightAndIndex.getValue(),boneIndex.byteValue());
                  }
                  weightToIndexMap.remove(lowestWeightAndIndex.getKey());
                  weightToIndexMap.put(weight,lowestWeightAndIndex.getValue());
                }
              }
              ++weightIndex;
            }
          }
        }
 else {
          for (          Integer index : vertexIndices) {
            weightsFloatData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX,0.0f);
            indicesData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX,(byte)0);
          }
        }
      }
      ++vertexIndex;
    }
    if (warnAboutTooManyVertexWeights) {
      LOGGER.log(Level.WARNING,"{0} has vertices with more than 4 weights assigned. The model may not behave as it should.",meshStructure.getName());
    }
  }
 else {
    for (    List<Integer> vertexIndexList : vertexReferenceMap.values()) {
      for (      Integer index : vertexIndexList) {
        weightsFloatData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX,1.0f);
        indicesData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX,(byte)0);
      }
    }
  }
  bonesGroups[0]=Math.max(bonesGroups[0],1);
  this.endBoneAssigns(vertexListSize,weightsFloatData);
  VertexBuffer verticesWeights=new VertexBuffer(Type.BoneWeight);
  verticesWeights.setupData(Usage.CpuOnly,bonesGroups[0],Format.Float,weightsFloatData);
  VertexBuffer verticesWeightsIndices=new VertexBuffer(Type.BoneIndex);
  verticesWeightsIndices.setupData(Usage.CpuOnly,bonesGroups[0],Format.UnsignedByte,indicesData);
  return new VertexBuffer[]{verticesWeights,verticesWeightsIndices};
}
