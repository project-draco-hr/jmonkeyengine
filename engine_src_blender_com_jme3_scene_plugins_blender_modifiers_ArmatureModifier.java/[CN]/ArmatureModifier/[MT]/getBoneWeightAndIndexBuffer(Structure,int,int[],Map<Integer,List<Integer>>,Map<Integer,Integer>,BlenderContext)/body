{
  bonesGroups[0]=0;
  Pointer pDvert=(Pointer)meshStructure.getFieldValue("dvert");
  FloatBuffer weightsFloatData=BufferUtils.createFloatBuffer(vertexListSize * MAXIMUM_WEIGHTS_PER_VERTEX);
  ByteBuffer indicesData=BufferUtils.createByteBuffer(vertexListSize * MAXIMUM_WEIGHTS_PER_VERTEX);
  if (pDvert.isNotNull()) {
    List<Structure> dverts=pDvert.fetchData(blenderContext.getInputStream());
    int vertexIndex=0;
    for (    Structure dvert : dverts) {
      List<Integer> vertexIndices=vertexReferenceMap.get(Integer.valueOf(vertexIndex));
      if (vertexIndices != null) {
        int totweight=((Number)dvert.getFieldValue("totweight")).intValue();
        Pointer pDW=(Pointer)dvert.getFieldValue("dw");
        if (totweight > 0 && pDW.isNotNull() && groupToBoneIndexMap != null) {
          int weightIndex=0;
          List<Structure> dw=pDW.fetchData(blenderContext.getInputStream());
          for (          Structure deformWeight : dw) {
            Integer boneIndex=groupToBoneIndexMap.get(((Number)deformWeight.getFieldValue("def_nr")).intValue());
            if (weightIndex == 4) {
              LOGGER.log(Level.WARNING,"{0} has more than 4 weight on bone index {1}",new Object[]{meshStructure.getName(),boneIndex});
              break;
            }
            if (boneIndex != null) {
              float weight=((Number)deformWeight.getFieldValue("weight")).floatValue();
              if (weight == 0.0f) {
                weight=1;
                boneIndex=Integer.valueOf(0);
              }
              for (              Integer index : vertexIndices) {
                weightsFloatData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX + weightIndex,weight);
                indicesData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX + weightIndex,boneIndex.byteValue());
              }
            }
            ++weightIndex;
          }
          bonesGroups[0]=Math.max(bonesGroups[0],weightIndex);
        }
 else {
          for (          Integer index : vertexIndices) {
            weightsFloatData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX,0.0f);
            indicesData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX,(byte)0);
          }
        }
      }
      ++vertexIndex;
    }
  }
 else {
    for (    List<Integer> vertexIndexList : vertexReferenceMap.values()) {
      for (      Integer index : vertexIndexList) {
        weightsFloatData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX,1.0f);
        indicesData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX,(byte)0);
      }
    }
  }
  bonesGroups[0]=Math.max(bonesGroups[0],1);
  this.endBoneAssigns(vertexListSize,weightsFloatData);
  VertexBuffer verticesWeights=new VertexBuffer(Type.BoneWeight);
  verticesWeights.setupData(Usage.CpuOnly,bonesGroups[0],Format.Float,weightsFloatData);
  VertexBuffer verticesWeightsIndices=new VertexBuffer(Type.BoneIndex);
  verticesWeightsIndices.setupData(Usage.CpuOnly,bonesGroups[0],Format.UnsignedByte,indicesData);
  return new VertexBuffer[]{verticesWeights,verticesWeightsIndices};
}
