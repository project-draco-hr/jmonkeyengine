{
  if (numLights == 0) {
    return 0;
  }
  Uniform lightData=shader.getUniform("g_LightData");
  lightData.setVector4Length(numLights * 3);
  Uniform ambientColor=shader.getUniform("g_AmbientLightColor");
  Uniform lightProbeData=shader.getUniform("g_LightProbeData");
  Uniform lightProbeIrrMap=shader.getUniform("g_IrradianceMap");
  Uniform lightProbePemMap=shader.getUniform("g_PrefEnvMap");
  if (startIndex != 0) {
    rm.getRenderer().applyRenderState(additiveLight);
    ambientColor.setValue(VarType.Vector4,ColorRGBA.Black);
  }
 else {
    ambientColor.setValue(VarType.Vector4,getAmbientColor(lightList,true));
  }
  int lightDataIndex=0;
  TempVars vars=TempVars.get();
  Vector4f tmpVec=vars.vect4f1;
  int curIndex;
  int endIndex=numLights + startIndex;
  boolean useIBL=false;
  for (curIndex=startIndex; curIndex < endIndex && curIndex < lightList.size(); curIndex++) {
    Light l=lightList.get(curIndex);
    if (l.getType() == Light.Type.Ambient) {
      endIndex++;
      continue;
    }
    ColorRGBA color=l.getColor();
    if (l.getType() != Light.Type.Probe) {
      lightData.setVector4InArray(color.getRed(),color.getGreen(),color.getBlue(),l.getType().getId(),lightDataIndex);
      lightDataIndex++;
    }
switch (l.getType()) {
case Directional:
      DirectionalLight dl=(DirectionalLight)l;
    Vector3f dir=dl.getDirection();
  tmpVec.set(dir.getX(),dir.getY(),dir.getZ(),0.0f);
transposeLightDataToSpace(technique.getDef().getLightSpace(),rm,tmpVec);
lightData.setVector4InArray(tmpVec.getX(),tmpVec.getY(),tmpVec.getZ(),-1,lightDataIndex);
lightDataIndex++;
lightData.setVector4InArray(0,0,0,0,lightDataIndex);
lightDataIndex++;
break;
case Point:
PointLight pl=(PointLight)l;
Vector3f pos=pl.getPosition();
float invRadius=pl.getInvRadius();
tmpVec.set(pos.getX(),pos.getY(),pos.getZ(),1.0f);
transposeLightDataToSpace(technique.getDef().getLightSpace(),rm,tmpVec);
lightData.setVector4InArray(tmpVec.getX(),tmpVec.getY(),tmpVec.getZ(),invRadius,lightDataIndex);
lightDataIndex++;
lightData.setVector4InArray(0,0,0,0,lightDataIndex);
lightDataIndex++;
break;
case Spot:
SpotLight sl=(SpotLight)l;
Vector3f pos2=sl.getPosition();
Vector3f dir2=sl.getDirection();
float invRange=sl.getInvSpotRange();
float spotAngleCos=sl.getPackedAngleCos();
tmpVec.set(pos2.getX(),pos2.getY(),pos2.getZ(),1.0f);
transposeLightDataToSpace(technique.getDef().getLightSpace(),rm,tmpVec);
lightData.setVector4InArray(tmpVec.getX(),tmpVec.getY(),tmpVec.getZ(),invRange,lightDataIndex);
lightDataIndex++;
tmpVec.set(dir2.getX(),dir2.getY(),dir2.getZ(),0.0f);
transposeLightDataToSpace(technique.getDef().getLightSpace(),rm,tmpVec);
lightData.setVector4InArray(tmpVec.getX(),tmpVec.getY(),tmpVec.getZ(),spotAngleCos,lightDataIndex);
lightDataIndex++;
break;
case Probe:
useIBL=true;
technique.setUseIndirectLighting(true);
endIndex++;
LightProbe probe=(LightProbe)l;
BoundingSphere s=(BoundingSphere)probe.getBounds();
tmpVec.set(probe.getPosition().x,probe.getPosition().y,probe.getPosition().z,1f / s.getRadius());
lightProbeData.setValue(VarType.Vector4,tmpVec);
if (irrUnit == -1) {
irrUnit=nextTexUnit++;
pemUnit=nextTexUnit++;
}
rm.getRenderer().setTexture(irrUnit,probe.getIrradianceMap());
lightProbeIrrMap.setValue(VarType.Int,irrUnit);
rm.getRenderer().setTexture(pemUnit,probe.getPrefilteredEnvMap());
lightProbePemMap.setValue(VarType.Int,pemUnit);
break;
default :
throw new UnsupportedOperationException("Unknown type of light: " + l.getType());
}
}
vars.release();
if (!useIBL) {
technique.setUseIndirectLighting(false);
}
while (lightDataIndex < numLights * 3) {
lightData.setVector4InArray(0f,0f,0f,0f,lightDataIndex);
lightDataIndex++;
}
return curIndex;
}
