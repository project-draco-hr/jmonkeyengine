{
  if (calculatedTrack == null) {
    int framesAmount=stopFrame - startFrame;
    float timeBetweenFrames=1.0f / fps;
    float[] times=new float[framesAmount + 1];
    Vector3f[] translations=new Vector3f[framesAmount + 1];
    float[] translation=new float[]{localTranslation.x,localTranslation.y,localTranslation.z};
    Quaternion[] rotations=new Quaternion[framesAmount + 1];
    float[] quaternionRotation=new float[]{localRotation.getX(),localRotation.getY(),localRotation.getZ(),localRotation.getW()};
    float[] objectRotation=localRotation.toAngles(null);
    Vector3f[] scales=new Vector3f[framesAmount + 1];
    float[] scale=new float[]{localScale.x,localScale.y,localScale.z};
    float degreeToRadiansFactor=1;
    if (blenderVersion < 250) {
      degreeToRadiansFactor*=FastMath.DEG_TO_RAD * 10;
    }
    int yIndex=1, zIndex=2;
    boolean swapAxes=spatialTrack && fixUpAxis;
    if (swapAxes) {
      yIndex=2;
      zIndex=1;
    }
    for (int frame=startFrame; frame <= stopFrame; ++frame) {
      int index=frame - startFrame;
      times[index]=index * timeBetweenFrames;
      for (int j=0; j < bezierCurves.length; ++j) {
        double value=bezierCurves[j].evaluate(frame,BezierCurve.Y_VALUE);
switch (bezierCurves[j].getType()) {
case AC_LOC_X:
          translation[0]=(float)value;
        break;
case AC_LOC_Y:
      if (swapAxes && value != 0) {
        value=-value;
      }
    translation[yIndex]=(float)value;
  break;
case AC_LOC_Z:
translation[zIndex]=(float)value;
break;
case OB_ROT_X:
objectRotation[0]=(float)value * degreeToRadiansFactor;
break;
case OB_ROT_Y:
if (swapAxes && value != 0) {
value=-value;
}
objectRotation[yIndex]=(float)value * degreeToRadiansFactor;
break;
case OB_ROT_Z:
objectRotation[zIndex]=(float)value * degreeToRadiansFactor;
break;
case AC_SIZE_X:
scale[0]=(float)value;
break;
case AC_SIZE_Y:
scale[yIndex]=(float)value;
break;
case AC_SIZE_Z:
scale[zIndex]=(float)value;
break;
case AC_QUAT_W:
quaternionRotation[3]=(float)value;
break;
case AC_QUAT_X:
quaternionRotation[0]=(float)value;
break;
case AC_QUAT_Y:
if (swapAxes && value != 0) {
value=-value;
}
quaternionRotation[yIndex]=(float)value;
break;
case AC_QUAT_Z:
quaternionRotation[zIndex]=(float)value;
break;
default :
LOGGER.log(Level.WARNING,"Unknown ipo curve type: {0}.",bezierCurves[j].getType());
}
}
translations[index]=localRotation.multLocal(new Vector3f(translation[0],translation[1],translation[2]));
rotations[index]=spatialTrack ? new Quaternion().fromAngles(objectRotation) : new Quaternion(quaternionRotation[0],quaternionRotation[1],quaternionRotation[2],quaternionRotation[3]);
scales[index]=new Vector3f(scale[0],scale[1],scale[2]);
}
if (spatialTrack) {
calculatedTrack=new SpatialTrack(times,translations,rotations,scales);
}
 else {
calculatedTrack=new BoneTrack(targetIndex,times,translations,rotations,scales);
}
}
return calculatedTrack;
}
