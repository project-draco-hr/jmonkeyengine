{
  Format format=image.getFormat();
  ByteBuffer data=image.getData(0);
  data.rewind();
  int width=image.getWidth();
  int height=image.getHeight();
  int depth=image.getDepth();
  if (depth == 0) {
    depth=1;
  }
  ByteBuffer newData=BufferUtils.createByteBuffer(data.remaining());
  PixelInputOutput basePixelIO=null;
  float[][] compressedMaterialColor=null;
  TexturePixel[] baseTextureColors=null;
  if (baseImage != null) {
    basePixelIO=PixelIOFactory.getPixelIO(baseImage.getFormat());
    compressedMaterialColor=new float[2][4];
    baseTextureColors=new TexturePixel[]{new TexturePixel(),new TexturePixel()};
  }
  float[] resultPixel=new float[4];
  float[] pixelColor=new float[4];
  TexturePixel[] colors=new TexturePixel[]{new TexturePixel(),new TexturePixel()};
  int dataIndex=0, baseXTexelIndex=0, baseYTexelIndex=0;
  float[] alphas=new float[]{1,1};
  while (data.hasRemaining()) {
    if (format == Format.DXT1A) {
      LOGGER.log(Level.WARNING,"Image type not yet supported for blending: {0}",format);
      break;
    }
    if (format == Format.DXT3) {
      long alpha=data.getLong();
      byte alpha0=(byte)(alpha << 4 & 0xFF);
      byte alpha1=(byte)(alpha >> 60 & 0xFF);
      alphas[0]=alpha0 >= 0 ? alpha0 / 255.0f : 1.0f - ~alpha0 / 255.0f;
      alphas[1]=alpha1 >= 0 ? alpha1 / 255.0f : 1.0f - ~alpha1 / 255.0f;
      dataIndex+=8;
    }
 else     if (format == Format.DXT5) {
      byte alpha0=data.get();
      byte alpha1=data.get();
      alphas[0]=alpha0 >= 0 ? alpha0 / 255.0f : 1.0f - ~alpha0 / 255.0f;
      alphas[1]=alpha1 >= 0 ? alpha0 / 255.0f : 1.0f - ~alpha0 / 255.0f;
      data.getInt();
      data.getShort();
      dataIndex+=8;
    }
    int col0=RGB565.RGB565_to_ARGB8(data.getShort());
    int col1=RGB565.RGB565_to_ARGB8(data.getShort());
    colors[0].fromARGB8(col0);
    colors[1].fromARGB8(col1);
    if (baseImage != null) {
      basePixelIO.read(baseImage,baseTextureColors[0],baseXTexelIndex << 2,baseYTexelIndex << 2);
      basePixelIO.read(baseImage,baseTextureColors[1],baseXTexelIndex << 2 + 4,baseYTexelIndex << 2 + 4);
      baseTextureColors[0].toRGBA(compressedMaterialColor[0]);
      baseTextureColors[1].toRGBA(compressedMaterialColor[1]);
    }
    for (int i=0; i < colors.length; ++i) {
      if (negateTexture) {
        colors[i].negate();
      }
      colors[i].toRGBA(pixelColor);
      pixelColor[3]=alphas[i];
      this.blendPixel(resultPixel,compressedMaterialColor != null ? compressedMaterialColor[i] : materialColor,pixelColor,blenderContext);
      colors[i].fromARGB8(1,resultPixel[0],resultPixel[1],resultPixel[2]);
      int argb8=colors[i].toARGB8();
      short rgb565=RGB565.ARGB8_to_RGB565(argb8);
      newData.putShort(dataIndex,rgb565);
      dataIndex+=2;
    }
    newData.putInt(dataIndex,data.getInt());
    dataIndex+=4;
    ++baseXTexelIndex;
    if (baseXTexelIndex > image.getWidth() >> 2) {
      baseXTexelIndex=0;
      ++baseYTexelIndex;
    }
  }
  if (depth > 1) {
    ArrayList<ByteBuffer> dataArray=new ArrayList<ByteBuffer>(1);
    dataArray.add(newData);
    return new Image(format,width,height,depth,dataArray);
  }
 else {
    return new Image(format,width,height,newData);
  }
}
