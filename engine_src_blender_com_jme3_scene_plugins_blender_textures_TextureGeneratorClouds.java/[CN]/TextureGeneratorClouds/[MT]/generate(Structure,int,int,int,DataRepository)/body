{
  float[] texvec=new float[]{0,0,0};
  TextureResult texres=new TextureResult();
  float noisesize=((Number)tex.getFieldValue("noisesize")).floatValue();
  int noiseDepth=((Number)tex.getFieldValue("noisedepth")).intValue();
  int noiseBasis=((Number)tex.getFieldValue("noisebasis")).intValue();
  int noiseType=((Number)tex.getFieldValue("noisetype")).intValue();
  boolean isHard=noiseType != TEX_NOISESOFT;
  int sType=((Number)tex.getFieldValue("stype")).intValue();
  int halfW=width >> 1, halfH=height >> 1, halfD=depth >> 1, index=0;
  float wDelta=1.0f / halfW, hDelta=1.0f / halfH, dDelta=1.0f / halfD;
  float[][] colorBand=this.computeColorband(tex,dataRepository);
  Format format=sType == TEX_COLOR || colorBand != null ? Format.RGB8 : Format.Luminance8;
  int bytesPerPixel=sType == TEX_COLOR || colorBand != null ? 3 : 1;
  BrightnessAndContrastData bacd=new BrightnessAndContrastData(tex);
  byte[] data=new byte[width * height * depth* bytesPerPixel];
  for (int i=-halfW; i < halfW; ++i) {
    texvec[0]=wDelta * i;
    for (int j=-halfH; j < halfH; ++j) {
      texvec[1]=hDelta * j;
      for (int k=-halfD; k < halfD; ++k) {
        texvec[2]=dDelta * k;
        texres.intensity=NoiseGenerator.NoiseFunctions.turbulence(texvec[0],texvec[1],texvec[2],noisesize,noiseDepth,noiseBasis,isHard);
        texres.intensity=FastMath.clamp(texres.intensity,0.0f,1.0f);
        if (colorBand != null) {
          int colorbandIndex=(int)(texres.intensity * 1000.0f);
          texres.red=colorBand[colorbandIndex][0];
          texres.green=colorBand[colorbandIndex][1];
          texres.blue=colorBand[colorbandIndex][2];
          this.applyBrightnessAndContrast(bacd,texres);
          data[index++]=(byte)(texres.red * 255.0f);
          data[index++]=(byte)(texres.green * 255.0f);
          data[index++]=(byte)(texres.blue * 255.0f);
        }
 else         if (sType == TEX_COLOR) {
          texres.red=texres.intensity;
          texres.green=NoiseGenerator.NoiseFunctions.turbulence(texvec[1],texvec[0],texvec[2],noisesize,noiseDepth,noiseBasis,isHard);
          texres.blue=NoiseGenerator.NoiseFunctions.turbulence(texvec[1],texvec[2],texvec[0],noisesize,noiseDepth,noiseBasis,isHard);
          texres.green=FastMath.clamp(texres.green,0.0f,1.0f);
          texres.blue=FastMath.clamp(texres.blue,0.0f,1.0f);
          this.applyBrightnessAndContrast(bacd,texres);
          data[index++]=(byte)(texres.red * 255.0f);
          data[index++]=(byte)(texres.green * 255.0f);
          data[index++]=(byte)(texres.blue * 255.0f);
        }
 else {
          this.applyBrightnessAndContrast(texres,bacd.contrast,bacd.brightness);
          data[index++]=(byte)(texres.intensity * 255.0f);
        }
      }
    }
  }
  ArrayList<ByteBuffer> dataArray=new ArrayList<ByteBuffer>(1);
  dataArray.add(BufferUtils.createByteBuffer(data));
  return new Texture3D(new Image(format,width,height,depth,dataArray));
}
