{
  super(blenderVersion);
  if (influenceFunctions == null) {
    influenceFunctions=new AbstractInfluenceFunction[ConstraintType.getLastDefinedTypeValue() + 1];
    influenceFunctions[ConstraintType.CONSTRAINT_TYPE_ACTION.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_ACTION,dataRepository){
    }
;
    influenceFunctions[ConstraintType.CONSTRAINT_TYPE_CHILDOF.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_CHILDOF,dataRepository){
    }
;
    influenceFunctions[ConstraintType.CONSTRAINT_TYPE_CLAMPTO.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_CLAMPTO,dataRepository){
      @Override public void affectAnimation(      Skeleton skeleton,      BoneAnimation boneAnimation,      Constraint constraint){
        this.validateConstraintType(constraint.getData());
        LOGGER.info(constraint.getName() + " not active! Curves not yet implemented!");
      }
    }
;
    influenceFunctions[ConstraintType.CONSTRAINT_TYPE_DISTLIMIT.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_DISTLIMIT,dataRepository){
      @Override public void affectAnimation(      Skeleton skeleton,      BoneAnimation boneAnimation,      Constraint constraint){
        Structure constraintStructure=constraint.getData();
        this.validateConstraintType(constraintStructure);
        Vector3f targetLocation=this.getTargetLocation(constraint);
        BoneTrack boneTrack=this.getBoneTrack(skeleton,boneAnimation,constraint);
        if (boneTrack != null) {
          float dist=((Number)constraintStructure.getFieldValue("dist")).floatValue();
          int mode=((Number)constraintStructure.getFieldValue("mode")).intValue();
          int maxFrames=boneTrack.getTimes().length;
          Vector3f[] translations=boneTrack.getTranslations();
          for (int frame=0; frame < maxFrames; ++frame) {
            Vector3f v=translations[frame].subtract(targetLocation);
            float currentDistance=v.length();
            float influence=constraint.getIpo().calculateValue(frame);
            float modifier=0.0f;
switch (mode) {
case LIMITDIST_INSIDE:
              if (currentDistance >= dist) {
                modifier=(dist - currentDistance) / currentDistance;
              }
            break;
case LIMITDIST_ONSURFACE:
          modifier=(dist - currentDistance) / currentDistance;
        break;
case LIMITDIST_OUTSIDE:
      if (currentDistance <= dist) {
        modifier=(dist - currentDistance) / currentDistance;
      }
    break;
default :
  throw new IllegalStateException("Unknown distance limit constraint mode: " + mode);
}
translations[frame].addLocal(v.multLocal(modifier * influence));
}
boneTrack.setKeyframes(boneTrack.getTimes(),translations,boneTrack.getRotations(),boneTrack.getScales());
}
}
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_FOLLOWPATH.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_FOLLOWPATH,dataRepository){
@Override public void affectAnimation(Skeleton skeleton,BoneAnimation boneAnimation,Constraint constraint){
this.validateConstraintType(constraint.getData());
LOGGER.info(constraint.getName() + " not active! Curves not yet implemented!");
}
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_KINEMATIC.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_KINEMATIC,dataRepository){
@Override public void affectAnimation(Skeleton skeleton,BoneAnimation boneAnimation,Constraint constraint){
Structure constraintStructure=constraint.getData();
this.validateConstraintType(constraintStructure);
}
/** 
 * This method returns bones used for rotation calculations.
 * @param bonethe bone to which the constraint is applied
 * @param skeletonthe skeleton owning the bone and its ancestors
 * @param boneAnimationthe bone animation data that stores the traces for the skeleton's bones
 * @return a list of bones to imitate the bone's movement during IK solving
 */
private CalculationBone[] getBonesToCalculate(Bone bone,Skeleton skeleton,BoneAnimation boneAnimation){
List<CalculationBone> bonesList=new ArrayList<CalculationBone>();
Bone currentBone=bone;
do {
int boneIndex=skeleton.getBoneIndex(currentBone);
for (int i=0; i < boneAnimation.getTracks().length; ++i) {
if (boneAnimation.getTracks()[i].getTargetBoneIndex() == boneIndex) {
bonesList.add(new CalculationBone(currentBone,boneAnimation.getTracks()[i]));
break;
}
}
currentBone=currentBone.getParent();
}
 while (currentBone != null);
CalculationBone[] result=bonesList.toArray(new CalculationBone[bonesList.size()]);
for (int i=result.length - 1; i > 0; --i) {
result[i].attachChild(result[i - 1]);
}
return result;
}
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_LOCKTRACK.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_LOCKTRACK,dataRepository){
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_LOCLIKE.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_LOCLIKE,dataRepository){
@Override public void affectAnimation(Skeleton skeleton,BoneAnimation boneAnimation,Constraint constraint){
Structure constraintData=constraint.getData();
this.validateConstraintType(constraintData);
BoneTrack boneTrack=this.getBoneTrack(skeleton,boneAnimation,constraint);
if (boneTrack != null) {
Vector3f targetLocation=this.getTargetLocation(constraint);
int flag=((Number)constraintData.getFieldValue("flag")).intValue();
Vector3f[] translations=boneTrack.getTranslations();
int maxFrames=translations.length;
for (int frame=0; frame < maxFrames; ++frame) {
Vector3f offset=Vector3f.ZERO;
if ((flag & LOCLIKE_OFFSET) != 0) {
offset=translations[frame].clone();
}
if ((flag & LOCLIKE_X) != 0) {
translations[frame].x=targetLocation.x;
if ((flag & LOCLIKE_X_INVERT) != 0) {
  translations[frame].x=-translations[frame].x;
}
}
 else if ((flag & LOCLIKE_Y) != 0) {
translations[frame].y=targetLocation.y;
if ((flag & LOCLIKE_Y_INVERT) != 0) {
  translations[frame].y=-translations[frame].y;
}
}
 else if ((flag & LOCLIKE_Z) != 0) {
translations[frame].z=targetLocation.z;
if ((flag & LOCLIKE_Z_INVERT) != 0) {
  translations[frame].z=-translations[frame].z;
}
}
translations[frame].addLocal(offset);
}
boneTrack.setKeyframes(boneTrack.getTimes(),translations,boneTrack.getRotations(),boneTrack.getScales());
}
}
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_LOCLIMIT.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_LOCLIMIT,dataRepository){
@Override public void affectAnimation(Skeleton skeleton,BoneAnimation boneAnimation,Constraint constraint){
Structure constraintStructure=constraint.getData();
this.validateConstraintType(constraintStructure);
BoneTrack boneTrack=this.getBoneTrack(skeleton,boneAnimation,constraint);
if (boneTrack != null) {
int flag=((Number)constraintStructure.getFieldValue("flag")).intValue();
Vector3f[] translations=boneTrack.getTranslations();
int maxFrames=translations.length;
for (int frame=0; frame < maxFrames; ++frame) {
float influence=constraint.getIpo().calculateValue(frame);
if ((flag & LIMIT_XMIN) != 0) {
float xmin=((Number)constraintStructure.getFieldValue("xmin")).floatValue();
if (translations[frame].x < xmin) {
  translations[frame].x-=(translations[frame].x - xmin) * influence;
}
}
if ((flag & LIMIT_XMAX) != 0) {
float xmax=((Number)constraintStructure.getFieldValue("xmax")).floatValue();
if (translations[frame].x > xmax) {
  translations[frame].x-=(translations[frame].x - xmax) * influence;
}
}
if ((flag & LIMIT_YMIN) != 0) {
float ymin=((Number)constraintStructure.getFieldValue("ymin")).floatValue();
if (translations[frame].y < ymin) {
  translations[frame].y-=(translations[frame].y - ymin) * influence;
}
}
if ((flag & LIMIT_YMAX) != 0) {
float ymax=((Number)constraintStructure.getFieldValue("ymax")).floatValue();
if (translations[frame].y > ymax) {
  translations[frame].y-=(translations[frame].y - ymax) * influence;
}
}
if ((flag & LIMIT_ZMIN) != 0) {
float zmin=((Number)constraintStructure.getFieldValue("zmin")).floatValue();
if (translations[frame].z < zmin) {
  translations[frame].z-=(translations[frame].z - zmin) * influence;
}
}
if ((flag & LIMIT_ZMAX) != 0) {
float zmax=((Number)constraintStructure.getFieldValue("zmax")).floatValue();
if (translations[frame].z > zmax) {
  translations[frame].z-=(translations[frame].z - zmax) * influence;
}
}
}
boneTrack.setKeyframes(boneTrack.getTimes(),translations,boneTrack.getRotations(),boneTrack.getScales());
}
}
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_MINMAX.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_MINMAX,dataRepository){
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_NULL.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_NULL,dataRepository){
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_PYTHON.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_PYTHON,dataRepository){
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_RIGIDBODYJOINT.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_RIGIDBODYJOINT,dataRepository){
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_ROTLIKE.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_ROTLIKE,dataRepository){
@Override public void affectAnimation(Skeleton skeleton,BoneAnimation boneAnimation,Constraint constraint){
Structure constraintData=constraint.getData();
this.validateConstraintType(constraintData);
BoneTrack boneTrack=this.getBoneTrack(skeleton,boneAnimation,constraint);
if (boneTrack != null) {
Quaternion targetRotation=this.getTargetRotation(constraint);
int flag=((Number)constraintData.getFieldValue("flag")).intValue();
float[] targetAngles=targetRotation.toAngles(null);
Quaternion[] rotations=boneTrack.getRotations();
int maxFrames=rotations.length;
for (int frame=0; frame < maxFrames; ++frame) {
float[] angles=rotations[frame].toAngles(null);
Quaternion offset=Quaternion.IDENTITY;
if ((flag & ROTLIKE_OFFSET) != 0) {
offset=rotations[frame].clone();
}
if ((flag & ROTLIKE_X) != 0) {
angles[0]=targetAngles[0];
if ((flag & ROTLIKE_X_INVERT) != 0) {
  angles[0]=-angles[0];
}
}
 else if ((flag & ROTLIKE_Y) != 0) {
angles[1]=targetAngles[1];
if ((flag & ROTLIKE_Y_INVERT) != 0) {
  angles[1]=-angles[1];
}
}
 else if ((flag & ROTLIKE_Z) != 0) {
angles[2]=targetAngles[2];
if ((flag & ROTLIKE_Z_INVERT) != 0) {
  angles[2]=-angles[2];
}
}
rotations[frame].fromAngles(angles).multLocal(offset);
}
boneTrack.setKeyframes(boneTrack.getTimes(),boneTrack.getTranslations(),rotations,boneTrack.getScales());
}
}
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_ROTLIMIT.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_ROTLIMIT,dataRepository){
@Override public void affectAnimation(Skeleton skeleton,BoneAnimation boneAnimation,Constraint constraint){
Structure constraintStructure=constraint.getData();
this.validateConstraintType(constraintStructure);
BoneTrack boneTrack=this.getBoneTrack(skeleton,boneAnimation,constraint);
if (boneTrack != null) {
int flag=((Number)constraintStructure.getFieldValue("flag")).intValue();
Quaternion[] rotations=boneTrack.getRotations();
int maxFrames=rotations.length;
for (int frame=0; frame < maxFrames; ++frame) {
float[] angles=rotations[frame].toAngles(null);
float influence=constraint.getIpo().calculateValue(frame);
if ((flag & LIMIT_XROT) != 0) {
float xmin=((Number)constraintStructure.getFieldValue("xmin")).floatValue() * FastMath.DEG_TO_RAD;
float xmax=((Number)constraintStructure.getFieldValue("xmax")).floatValue() * FastMath.DEG_TO_RAD;
float difference=0.0f;
if (angles[0] < xmin) {
  difference=(angles[0] - xmin) * influence;
}
 else if (angles[0] > xmax) {
  difference=(angles[0] - xmax) * influence;
}
angles[0]-=difference;
}
if ((flag & LIMIT_YROT) != 0) {
float ymin=((Number)constraintStructure.getFieldValue("ymin")).floatValue() * FastMath.DEG_TO_RAD;
float ymax=((Number)constraintStructure.getFieldValue("ymax")).floatValue() * FastMath.DEG_TO_RAD;
float difference=0.0f;
if (angles[1] < ymin) {
  difference=(angles[1] - ymin) * influence;
}
 else if (angles[1] > ymax) {
  difference=(angles[1] - ymax) * influence;
}
angles[1]-=difference;
}
if ((flag & LIMIT_ZROT) != 0) {
float zmin=((Number)constraintStructure.getFieldValue("zmin")).floatValue() * FastMath.DEG_TO_RAD;
float zmax=((Number)constraintStructure.getFieldValue("zmax")).floatValue() * FastMath.DEG_TO_RAD;
float difference=0.0f;
if (angles[2] < zmin) {
  difference=(angles[2] - zmin) * influence;
}
 else if (angles[2] > zmax) {
  difference=(angles[2] - zmax) * influence;
}
angles[2]-=difference;
}
rotations[frame].fromAngles(angles);
}
boneTrack.setKeyframes(boneTrack.getTimes(),boneTrack.getTranslations(),rotations,boneTrack.getScales());
}
}
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_SHRINKWRAP.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_SHRINKWRAP,dataRepository){
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_SIZELIKE.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_SIZELIKE,dataRepository){
@Override public void affectAnimation(Skeleton skeleton,BoneAnimation boneAnimation,Constraint constraint){
Structure constraintData=constraint.getData();
this.validateConstraintType(constraintData);
Vector3f targetScale=this.getTargetLocation(constraint);
BoneTrack boneTrack=this.getBoneTrack(skeleton,boneAnimation,constraint);
if (boneTrack != null) {
int flag=((Number)constraintData.getFieldValue("flag")).intValue();
Vector3f[] scales=boneTrack.getScales();
int maxFrames=scales.length;
for (int frame=0; frame < maxFrames; ++frame) {
Vector3f offset=Vector3f.ZERO;
if ((flag & LOCLIKE_OFFSET) != 0) {
offset=scales[frame].clone();
}
if ((flag & SIZELIKE_X) != 0) {
scales[frame].x=targetScale.x;
}
 else if ((flag & SIZELIKE_Y) != 0) {
scales[frame].y=targetScale.y;
}
 else if ((flag & SIZELIKE_Z) != 0) {
scales[frame].z=targetScale.z;
}
scales[frame].addLocal(offset);
}
boneTrack.setKeyframes(boneTrack.getTimes(),boneTrack.getTranslations(),boneTrack.getRotations(),scales);
}
}
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_SIZELIMIT.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_SIZELIMIT,dataRepository){
@Override public void affectAnimation(Skeleton skeleton,BoneAnimation boneAnimation,Constraint constraint){
Structure constraintStructure=constraint.getData();
this.validateConstraintType(constraintStructure);
BoneTrack boneTrack=this.getBoneTrack(skeleton,boneAnimation,constraint);
if (boneTrack != null) {
int flag=((Number)constraintStructure.getFieldValue("flag")).intValue();
Vector3f[] scales=boneTrack.getScales();
int maxFrames=scales.length;
for (int frame=0; frame < maxFrames; ++frame) {
float influence=constraint.getIpo().calculateValue(frame);
if ((flag & LIMIT_XMIN) != 0) {
float xmin=((Number)constraintStructure.getFieldValue("xmin")).floatValue();
if (scales[frame].x < xmin) {
  scales[frame].x-=(scales[frame].x - xmin) * influence;
}
}
if ((flag & LIMIT_XMAX) != 0) {
float xmax=((Number)constraintStructure.getFieldValue("xmax")).floatValue();
if (scales[frame].x > xmax) {
  scales[frame].x-=(scales[frame].x - xmax) * influence;
}
}
if ((flag & LIMIT_YMIN) != 0) {
float ymin=((Number)constraintStructure.getFieldValue("ymin")).floatValue();
if (scales[frame].y < ymin) {
  scales[frame].y-=(scales[frame].y - ymin) * influence;
}
}
if ((flag & LIMIT_YMAX) != 0) {
float ymax=((Number)constraintStructure.getFieldValue("ymax")).floatValue();
if (scales[frame].y > ymax) {
  scales[frame].y-=(scales[frame].y - ymax) * influence;
}
}
if ((flag & LIMIT_ZMIN) != 0) {
float zmin=((Number)constraintStructure.getFieldValue("zmin")).floatValue();
if (scales[frame].z < zmin) {
  scales[frame].z-=(scales[frame].z - zmin) * influence;
}
}
if ((flag & LIMIT_ZMAX) != 0) {
float zmax=((Number)constraintStructure.getFieldValue("zmax")).floatValue();
if (scales[frame].z > zmax) {
  scales[frame].z-=(scales[frame].z - zmax) * influence;
}
}
}
boneTrack.setKeyframes(boneTrack.getTimes(),boneTrack.getTranslations(),boneTrack.getRotations(),scales);
}
}
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_STRETCHTO.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_STRETCHTO,dataRepository){
}
;
influenceFunctions[ConstraintType.CONSTRAINT_TYPE_TRANSFORM.getConstraintId()]=new AbstractInfluenceFunction(ConstraintType.CONSTRAINT_TYPE_TRANSFORM,dataRepository){
}
;
}
}
