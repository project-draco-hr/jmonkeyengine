{
  if (output.capacity() < input.capacity())   throw new RuntimeException("Output must be at least as large as input!");
  Vector3f offset=bbox.getCenter().negate();
  Vector3f size=new Vector3f(bbox.getXExtent(),bbox.getYExtent(),bbox.getZExtent());
  size.multLocal(2);
  ShortBuffer sb=null;
  ByteBuffer bb=null;
  float dataTypeSize;
  float dataTypeOffset;
  if (output instanceof ShortBuffer) {
    sb=(ShortBuffer)output;
    dataTypeOffset=shortOff;
    dataTypeSize=shortSize;
  }
 else {
    bb=(ByteBuffer)output;
    dataTypeOffset=byteOff;
    dataTypeSize=byteSize;
  }
  Vector3f scale=new Vector3f();
  scale.set(dataTypeSize,dataTypeSize,dataTypeSize).divideLocal(size);
  Vector3f invScale=new Vector3f();
  invScale.set(size).divideLocal(dataTypeSize);
  offset.multLocal(scale);
  offset.addLocal(dataTypeOffset,dataTypeOffset,dataTypeOffset);
  input.clear();
  output.clear();
  Vector3f temp=new Vector3f();
  int vertexCount=input.capacity() / 3;
  for (int i=0; i < vertexCount; i++) {
    BufferUtils.populateFromBuffer(temp,input,i);
    temp.multLocal(scale);
    temp.addLocal(offset);
    if (sb != null) {
      short v1=(short)temp.getX();
      short v2=(short)temp.getY();
      short v3=(short)temp.getZ();
      sb.put(v1).put(v2).put(v3);
    }
 else {
      byte v1=(byte)temp.getX();
      byte v2=(byte)temp.getY();
      byte v3=(byte)temp.getZ();
      bb.put(v1).put(v2).put(v3);
    }
  }
  Transform transform=new Transform();
  transform.setTranslation(offset.negate().multLocal(invScale));
  transform.setScale(invScale);
  return transform;
}
