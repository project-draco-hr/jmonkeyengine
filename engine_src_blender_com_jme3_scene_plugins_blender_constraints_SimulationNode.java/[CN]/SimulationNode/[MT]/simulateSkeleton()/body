{
  if (constraints != null && constraints.size() > 0) {
    boolean applyStaticConstraints=true;
    if (animations != null) {
      TempVars vars=TempVars.get();
      AnimChannel animChannel=animControl.createChannel();
      for (      Animation animation : animations) {
        float[] animationTimeBoundaries=this.computeAnimationTimeBoundaries(animation);
        int maxFrame=(int)animationTimeBoundaries[0];
        float maxTime=animationTimeBoundaries[1];
        Map<Integer,VirtualTrack> tracks=new HashMap<Integer,VirtualTrack>();
        Map<Integer,Transform> previousTransforms=new HashMap<Integer,Transform>();
        for (int frame=0; frame < maxFrame; ++frame) {
          this.reset();
          for (          Track track : animation.getTracks()) {
            float time=((BoneTrack)track).getTimes()[frame];
            Integer boneIndex=((BoneTrack)track).getTargetBoneIndex();
            track.setTime(time,1,animControl,animChannel,vars);
            skeleton.updateWorldVectors();
            Transform previousTransform=previousTransforms.get(boneIndex);
            if (previousTransform == null) {
              Bone bone=skeleton.getBone(boneIndex);
              previousTransform=new Transform();
              previousTransform.setTranslation(bone.getLocalPosition());
              previousTransform.setRotation(bone.getLocalRotation());
              previousTransform.setScale(bone.getLocalScale());
              previousTransforms.put(boneIndex,previousTransform);
            }
          }
          for (          Constraint constraint : constraints) {
            constraint.apply(frame);
          }
          for (          Track track : animation.getTracks()) {
            Integer boneIndex=((BoneTrack)track).getTargetBoneIndex();
            Bone bone=skeleton.getBone(boneIndex);
            Transform previousTransform=previousTransforms.get(boneIndex);
            VirtualTrack vTrack=tracks.get(boneIndex);
            if (vTrack == null) {
              vTrack=new VirtualTrack(maxFrame,maxTime);
              tracks.put(boneIndex,vTrack);
            }
            Vector3f bonePositionDifference=bone.getLocalPosition().subtract(previousTransform.getTranslation());
            Quaternion boneRotationDifference=bone.getLocalRotation().mult(previousTransform.getRotation().inverse()).normalizeLocal();
            Vector3f boneScaleDifference=bone.getLocalScale().divide(previousTransform.getScale());
            if (frame > 0) {
              bonePositionDifference=vTrack.translations.get(frame - 1).add(bonePositionDifference);
              boneRotationDifference=vTrack.rotations.get(frame - 1).mult(boneRotationDifference);
              boneScaleDifference=vTrack.scales.get(frame - 1).mult(boneScaleDifference);
            }
            vTrack.setTransform(frame,new Transform(bonePositionDifference,boneRotationDifference,boneScaleDifference));
            previousTransform.setTranslation(bone.getLocalPosition());
            previousTransform.setRotation(bone.getLocalRotation());
            previousTransform.setScale(bone.getLocalScale());
          }
        }
        for (        Entry<Integer,VirtualTrack> trackEntry : tracks.entrySet()) {
          Track newTrack=trackEntry.getValue().getAsBoneTrack(trackEntry.getKey());
          if (newTrack != null) {
            for (            Track track : animation.getTracks()) {
              if (((BoneTrack)track).getTargetBoneIndex() == trackEntry.getKey().intValue()) {
                animation.removeTrack(track);
                animation.addTrack(newTrack);
                break;
              }
            }
          }
          applyStaticConstraints=false;
        }
      }
      vars.release();
      animControl.clearChannels();
      this.reset();
    }
    if (applyStaticConstraints) {
      for (      Constraint constraint : constraints) {
        constraint.apply(0);
      }
    }
  }
}
