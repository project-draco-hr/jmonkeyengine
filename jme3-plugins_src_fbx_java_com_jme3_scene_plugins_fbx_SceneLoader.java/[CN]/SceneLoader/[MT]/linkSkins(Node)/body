{
  for (  long nodeId : modelDataMap.keySet()) {
    ModelData data=modelDataMap.get(nodeId);
    if (data.type.equals("LimbNode")) {
      Limb limb=createLimb(data);
      limbMap.put(nodeId,limb);
    }
  }
  if (limbMap.size() == 0)   return;
  Map<Long,Bone> bones=new HashMap<Long,Bone>();
  for (  long limbId : limbMap.keySet()) {
    Limb limb=limbMap.get(limbId);
    Bone bone=new Bone(limb.name);
    Transform t=limb.bindTransform;
    bone.setBindTransforms(t.getTranslation(),t.getRotation(),t.getScale());
    bones.put(limbId,bone);
  }
  for (  long limbId : limbMap.keySet()) {
    List<Long> refs=refMap.get(limbId);
    if (refs == null)     continue;
    long rootLimbId=0L;
    for (    long refId : refs) {
      if (limbMap.containsKey(refId)) {
        rootLimbId=refId;
        break;
      }
    }
    if (rootLimbId != 0L) {
      Bone bone=bones.get(limbId);
      Bone root=bones.get(rootLimbId);
      root.addChild(bone);
    }
  }
  for (  long clusterId : clusterMap.keySet()) {
    List<Long> refs=refMap.get(clusterId);
    if (refs == null)     continue;
    for (    long skinId : refs) {
      if (skinMap.containsKey(skinId)) {
        ClusterData data=clusterMap.get(clusterId);
        data.skinId=skinId;
        break;
      }
    }
  }
  this.skeleton=new Skeleton(bones.values().toArray(new Bone[0]));
  skeleton.setBindingPose();
  for (  long limbId : bones.keySet()) {
    Bone bone=bones.get(limbId);
    Limb limb=limbMap.get(limbId);
    limb.boneIndex=skeleton.getBoneIndex(bone);
  }
  for (  long skinId : skinMap.keySet()) {
    Mesh mesh=null;
    MeshData meshData=null;
    for (    long meshId : refMap.get(skinId)) {
      Geometry g=geomMap.get(meshId);
      if (g != null) {
        meshData=meshDataMap.get(meshId);
        mesh=g.getMesh();
        break;
      }
    }
    if (mesh != null && meshData != null) {
      FloatBuffer boneWeightData=BufferUtils.createFloatBuffer(meshData.vCount * 4);
      ByteBuffer boneIndicesData=BufferUtils.createByteBuffer(meshData.vCount * 4);
      mesh.setBuffer(VertexBuffer.Type.BoneWeight,4,boneWeightData);
      mesh.setBuffer(VertexBuffer.Type.BoneIndex,4,boneIndicesData);
      mesh.getBuffer(VertexBuffer.Type.BoneWeight).setUsage(Usage.CpuOnly);
      mesh.getBuffer(VertexBuffer.Type.BoneIndex).setUsage(Usage.CpuOnly);
      VertexBuffer weightsHW=new VertexBuffer(Type.HWBoneWeight);
      VertexBuffer indicesHW=new VertexBuffer(Type.HWBoneIndex);
      indicesHW.setUsage(Usage.CpuOnly);
      weightsHW.setUsage(Usage.CpuOnly);
      mesh.setBuffer(weightsHW);
      mesh.setBuffer(indicesHW);
      boolean bonesLimitExceeded=false;
      for (      long limbId : bones.keySet()) {
        ClusterData cluster=null;
        for (        long clusterId : refMap.get(limbId)) {
          ClusterData data=clusterMap.get(clusterId);
          if (data != null && data.skinId == skinId) {
            cluster=data;
            break;
          }
        }
        if (cluster == null || cluster.indexes == null || cluster.weights == null || cluster.indexes.length != cluster.weights.length)         continue;
        Limb limb=limbMap.get(limbId);
        if (limb.boneIndex > 255)         throw new AssetLoadException("Bone index can't be packed into byte");
        for (int i=0; i < cluster.indexes.length; ++i) {
          int vertexIndex=cluster.indexes[i];
          if (vertexIndex >= meshData.reverseVertexMap.size())           throw new AssetLoadException("Invalid skinning vertex index. Unexpected index lookup " + vertexIndex + " from "+ meshData.reverseVertexMap.size());
          List<Integer> dstVertices=meshData.reverseVertexMap.get(vertexIndex);
          for (          int v : dstVertices) {
            int offset;
            float w=0;
            for (offset=v * 4; offset < v * 4 + 4; ++offset) {
              w=boneWeightData.get(offset);
              if (w == 0)               break;
            }
            if (w == 0) {
              boneWeightData.put(offset,(float)cluster.weights[i]);
              boneIndicesData.put(offset,(byte)limb.boneIndex);
            }
 else {
              bonesLimitExceeded=true;
            }
          }
        }
      }
      if (bonesLimitExceeded)       logger.log(Level.WARNING,"Skinning support max 4 bone per vertex. Exceeding data will be discarded.");
      int maxWeightsPerVert=0;
      boneWeightData.rewind();
      for (int v=0; v < meshData.vCount; v++) {
        float w0=boneWeightData.get();
        float w1=boneWeightData.get();
        float w2=boneWeightData.get();
        float w3=boneWeightData.get();
        if (w3 != 0) {
          maxWeightsPerVert=Math.max(maxWeightsPerVert,4);
        }
 else         if (w2 != 0) {
          maxWeightsPerVert=Math.max(maxWeightsPerVert,3);
        }
 else         if (w1 != 0) {
          maxWeightsPerVert=Math.max(maxWeightsPerVert,2);
        }
 else         if (w0 != 0) {
          maxWeightsPerVert=Math.max(maxWeightsPerVert,1);
        }
        float sum=w0 + w1 + w2+ w3;
        if (sum != 1f) {
          float mult=(sum != 0) ? (1f / sum) : 0;
          boneWeightData.position(v * 4);
          boneWeightData.put(w0 * mult);
          boneWeightData.put(w1 * mult);
          boneWeightData.put(w2 * mult);
          boneWeightData.put(w3 * mult);
        }
      }
      mesh.setMaxNumWeights(maxWeightsPerVert);
      mesh.generateBindPose(true);
    }
  }
  animControl=new AnimControl(skeleton);
  sceneNode.addControl(animControl);
  SkeletonControl control=new SkeletonControl(skeleton);
  sceneNode.addControl(control);
}
