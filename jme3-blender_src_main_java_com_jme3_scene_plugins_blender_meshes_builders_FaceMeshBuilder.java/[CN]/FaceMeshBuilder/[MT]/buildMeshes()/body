{
  Map<Integer,Mesh> result=new HashMap<Integer,Mesh>(indexMap.size());
  for (  Entry<Integer,List<Integer>> meshEntry : indexMap.entrySet()) {
    int materialIndex=meshEntry.getKey();
    Mesh mesh=new Mesh();
    List<Integer> indexList=meshEntry.getValue();
    if (this.getVerticesAmount(materialIndex) <= Short.MAX_VALUE) {
      short[] indices=new short[indexList.size()];
      for (int i=0; i < indexList.size(); ++i) {
        indices[i]=indexList.get(i).shortValue();
      }
      mesh.setBuffer(Type.Index,1,indices);
    }
 else {
      int[] indices=new int[indexList.size()];
      for (int i=0; i < indexList.size(); ++i) {
        indices[i]=indexList.get(i).intValue();
      }
      mesh.setBuffer(Type.Index,1,indices);
    }
    LOGGER.fine("Creating vertices buffer.");
    VertexBuffer verticesBuffer=new VertexBuffer(Type.Position);
    verticesBuffer.setupData(Usage.Static,3,Format.Float,BufferUtils.createFloatBuffer(this.getVertices(materialIndex)));
    mesh.setBuffer(verticesBuffer);
    LOGGER.fine("Creating normals buffer.");
    VertexBuffer normalsBuffer=new VertexBuffer(Type.Normal);
    normalsBuffer.setupData(Usage.Static,3,Format.Float,BufferUtils.createFloatBuffer(this.getNormals(materialIndex)));
    mesh.setBuffer(normalsBuffer);
    if (verticesColors != null) {
      LOGGER.fine("Setting vertices colors.");
      mesh.setBuffer(Type.Color,4,this.getVertexColorsBuffer(materialIndex));
      mesh.getBuffer(Type.Color).setNormalized(true);
    }
    result.put(materialIndex,mesh);
  }
  return result;
}
