def _node_export(self, ob, url='', doc=None, rex=None, exported_meshes=[], meshes=[], mesh_collision_prims={}, mesh_collision_files={}, prefix='', objects=[], xmlparent=None):
    o = _ogre_node_helper(doc, ob, objects)
    xmlparent.appendChild(o)
    for prop in ob.items():
        (propname, propvalue) = prop
        if (not propname.startswith('_')):
            user = doc.createElement('user_data')
            o.appendChild(user)
            user.setAttribute('name', propname)
            user.setAttribute('value', str(propvalue))
            user.setAttribute('type', type(propvalue).__name__)
    for prop in ob.game.properties:
        e = doc.createElement('user_data')
        o.appendChild(e)
        e.setAttribute('name', prop.name)
        e.setAttribute('value', str(prop.value))
        e.setAttribute('type', type(prop.value).__name__)
    game = doc.createElement('game')
    o.appendChild(game)
    sens = doc.createElement('sensors')
    game.appendChild(sens)
    acts = doc.createElement('actuators')
    game.appendChild(acts)
    for sen in ob.game.sensors:
        sens.appendChild(WrapSensor(sen).xml(doc))
    for act in ob.game.actuators:
        acts.appendChild(WrapActuator(act).xml(doc))
    if (ob.type == 'MESH'):
        ob.data.update(calc_tessface=True)
    if ((ob.type == 'MESH') and len(ob.data.tessfaces)):
        collisionFile = None
        collisionPrim = None
        if (ob.data.name in mesh_collision_prims):
            collisionPrim = mesh_collision_prims[ob.data.name]
        if (ob.data.name in mesh_collision_files):
            collisionFile = mesh_collision_files[ob.data.name]
        e = doc.createElement('entity')
        o.appendChild(e)
        e.setAttribute('name', ob.data.name)
        prefix = ''
        e.setAttribute('meshFile', ('%s%s.mesh' % (prefix, ob.data.name)))
        if ((not collisionPrim) and (not collisionFile)):
            if ob.game.use_collision_bounds:
                collisionPrim = ob.game.collision_bounds_type.lower()
                mesh_collision_prims[ob.data.name] = collisionPrim
            else:
                for child in ob.children:
                    if (child.subcollision and child.name.startswith('DECIMATE')):
                        collisionFile = ('%s_collision_%s.mesh' % (prefix, ob.data.name))
                        break
                if collisionFile:
                    mesh_collision_files[ob.data.name] = collisionFile
                    self.dot_mesh(child, path=os.path.split(url)[0], force_name=('_collision_%s' % ob.data.name))
        if collisionPrim:
            e.setAttribute('collisionPrim', collisionPrim)
        elif collisionFile:
            e.setAttribute('collisionFile', collisionFile)
        _mesh_entity_helper(doc, ob, e)
        if self.EX_MESH:
            murl = os.path.join(os.path.split(url)[0], ('%s.mesh' % ob.data.name))
            exists = os.path.isfile(murl)
            if ((not exists) or (exists and self.EX_MESH_OVERWRITE)):
                if (ob.data.name not in exported_meshes):
                    exported_meshes.append(ob.data.name)
                    self.dot_mesh(ob, os.path.split(url)[0])
        vecs = [ob.matrix_world.to_translation()]
        for mod in ob.modifiers:
            if (mod.type == 'ARRAY'):
                if (mod.fit_type != 'FIXED_COUNT'):
                    print ('WARNING: unsupport array-modifier type->', mod.fit_type)
                    continue
                if (not mod.use_constant_offset):
                    print 'WARNING: unsupport array-modifier mode, must be "constant offset" type'
                    continue
                else:
                    newvecs = []
                    for prev in vecs:
                        for i in range((mod.count - 1)):
                            v = (prev + mod.constant_offset_displace)
                            newvecs.append(v)
                            ao = _ogre_node_helper(doc, ob, objects, prefix=('_array_%s_' % len((vecs + newvecs))), pos=v)
                            xmlparent.appendChild(ao)
                            e = doc.createElement('entity')
                            ao.appendChild(e)
                            e.setAttribute('name', ob.data.name)
                            e.setAttribute('meshFile', ('%s.mesh' % ob.data.name))
                            if collisionPrim:
                                e.setAttribute('collisionPrim', collisionPrim)
                            elif collisionFile:
                                e.setAttribute('collisionFile', collisionFile)
                    vecs += newvecs
    elif (ob.type == 'CAMERA'):
        Report.cameras.append(ob.name)
        c = doc.createElement('camera')
        o.appendChild(c)
        c.setAttribute('name', ob.data.name)
        aspx = bpy.context.scene.render.pixel_aspect_x
        aspy = bpy.context.scene.render.pixel_aspect_y
        sx = bpy.context.scene.render.resolution_x
        sy = bpy.context.scene.render.resolution_y
        fovY = 0.0
        if ((sx * aspx) > (sy * aspy)):
            fovY = (2 * math.atan((((sy * aspy) * 16.0) / ((ob.data.lens * sx) * aspx))))
        else:
            fovY = (2 * math.atan((16.0 / ob.data.lens)))
        fov = math.radians(((fovY * 180.0) / math.pi))
        c.setAttribute('fov', ('%s' % fov))
        c.setAttribute('projectionType', 'perspective')
        a = doc.createElement('clipping')
        c.appendChild(a)
        a.setAttribute('nearPlaneDist', ('%s' % ob.data.clip_start))
        a.setAttribute('farPlaneDist', ('%s' % ob.data.clip_end))
        a.setAttribute('near', ('%s' % ob.data.clip_start))
        a.setAttribute('far', ('%s' % ob.data.clip_end))
    elif ((ob.type == 'LAMP') and (ob.data.type in 'POINT SPOT SUN'.split())):
        Report.lights.append(ob.name)
        l = doc.createElement('light')
        o.appendChild(l)
        mat = (get_parent_matrix(ob, objects).inverted() * ob.matrix_world)
        p = doc.createElement('position')
        l.appendChild(p)
        v = swap(ob.matrix_world.to_translation())
        p.setAttribute('x', ('%6f' % v.x))
        p.setAttribute('y', ('%6f' % v.y))
        p.setAttribute('z', ('%6f' % v.z))
        if (ob.data.type == 'POINT'):
            l.setAttribute('type', 'point')
        elif (ob.data.type == 'SPOT'):
            l.setAttribute('type', 'spot')
        elif (ob.data.type == 'SUN'):
            l.setAttribute('type', 'directional')
        l.setAttribute('name', ob.name)
        l.setAttribute('powerScale', str(ob.data.energy))
        a = doc.createElement('lightAttenuation')
        l.appendChild(a)
        a.setAttribute('range', '5000')
        a.setAttribute('constant', '1.0')
        a.setAttribute('linear', ('%s' % (1.0 / ob.data.distance)))
        a.setAttribute('quadratic', '0.0')
        if (ob.data.type in ('SPOT', 'SUN')):
            vector = swap(mathutils.Euler.to_matrix(ob.rotation_euler)[2])
            a = doc.createElement('direction')
            l.appendChild(a)
            a.setAttribute('x', str(round((- vector[0]), 3)))
            a.setAttribute('y', str(round((- vector[1]), 3)))
            a.setAttribute('z', str(round((- vector[2]), 3)))
        if (ob.data.type == 'SPOT'):
            a = doc.createElement('spotLightRange')
            l.appendChild(a)
            a.setAttribute('inner', str((ob.data.spot_size * (1.0 - ob.data.spot_blend))))
            a.setAttribute('outer', str(ob.data.spot_size))
            a.setAttribute('falloff', '1.0')
        if ob.data.use_diffuse:
            a = doc.createElement('colourDiffuse')
            l.appendChild(a)
            a.setAttribute('r', ('%s' % ob.data.color.r))
            a.setAttribute('g', ('%s' % ob.data.color.g))
            a.setAttribute('b', ('%s' % ob.data.color.b))
        if ob.data.use_specular:
            a = doc.createElement('colourSpecular')
            l.appendChild(a)
            a.setAttribute('r', ('%s' % ob.data.color.r))
            a.setAttribute('g', ('%s' % ob.data.color.g))
            a.setAttribute('b', ('%s' % ob.data.color.b))
        if (ob.data.type != 'HEMI'):
            if (ob.data.shadow_method != 'NOSHADOW'):
                a = doc.createElement('colourShadow')
                l.appendChild(a)
                a.setAttribute('r', ('%s' % ob.data.color.r))
                a.setAttribute('g', ('%s' % ob.data.color.g))
                a.setAttribute('b', ('%s' % ob.data.color.b))
                l.setAttribute('shadow', 'true')
    for child in ob.children:
        self._node_export(child, url=url, doc=doc, rex=rex, exported_meshes=exported_meshes, meshes=meshes, mesh_collision_prims=mesh_collision_prims, mesh_collision_files=mesh_collision_files, prefix=prefix, objects=objects, xmlparent=o)
