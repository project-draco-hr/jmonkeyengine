def dot_mesh(ob, path='/tmp', force_name=None, ignore_shape_animation=False, normals=True):
    start = time.time()
    print ('mesh to Ogre mesh XML format', ob.name)
    if (not os.path.isdir(path)):
        print ('creating directory', path)
        os.makedirs(path)
    Report.meshes.append(ob.data.name)
    Report.faces += len(ob.data.tessfaces)
    Report.orig_vertices += len(ob.data.vertices)
    cleanup = False
    if ob.modifiers:
        cleanup = True
        copy = ob.copy()
        rem = []
        for mod in copy.modifiers:
            if (mod.type in 'ARMATURE ARRAY'.split()):
                rem.append(mod)
        for mod in rem:
            copy.modifiers.remove(mod)
        mesh = copy.to_mesh(bpy.context.scene, True, 'PREVIEW')
    else:
        copy = ob
        mesh = ob.data
    print 'creating document...'
    name = (force_name or ob.data.name)
    xmlfile = os.path.join(path, ('%s.mesh.xml' % name))
    if (_USE_RPYTHON_ and False):
        Rmesh.save(ob, xmlfile)
    else:
        f = open(xmlfile, 'w')
        doc = SimpleSaxWriter(f, 'UTF-8', 'mesh', {})
        doc.start_tag('sharedgeometry', {'vertexcount': '__TO_BE_REPLACED_VERTEX_COUNT__', })
        print '    writing shared geometry'
        doc.start_tag('vertexbuffer', {'positions': 'true', 'normals': 'true', 'colours_diffuse': str(bool(mesh.vertex_colors)), 'texture_coords': (('%s' % len(mesh.uv_textures)) if mesh.uv_textures.active else '0'), })
        vcolors = None
        vcolors_alpha = None
        if len(mesh.tessface_vertex_colors):
            vcolors = mesh.tessface_vertex_colors[0]
            for bloc in mesh.tessface_vertex_colors:
                if bloc.name.lower().startswith('alpha'):
                    vcolors_alpha = bloc
                    break
        materials = []
        for mat in ob.data.materials:
            if mat:
                materials.append(mat)
            else:
                print ('WARNING: bad material data', ob)
                materials.append('_missing_material_')
        if (not materials):
            materials.append('_missing_material_')
        _sm_faces_ = []
        for (matidx, mat) in enumerate(materials):
            _sm_faces_.append([])
        dotextures = False
        uvcache = []
        if mesh.tessface_uv_textures.active:
            dotextures = True
            for layer in mesh.tessface_uv_textures:
                uvs = []
                uvcache.append(uvs)
                for uvface in layer.data:
                    uvs.append((uvface.uv1, uvface.uv2, uvface.uv3, uvface.uv4))
        _sm_vertices_ = {}
        _remap_verts_ = []
        numverts = 0
        for F in mesh.tessfaces:
            smooth = F.use_smooth
            faces = _sm_faces_[F.material_index]
            tris = []
            tris.append((F.vertices[0], F.vertices[1], F.vertices[2]))
            if (len(F.vertices) >= 4):
                tris.append((F.vertices[0], F.vertices[2], F.vertices[3]))
            if dotextures:
                a = []
                b = []
                uvtris = [a, b]
                for layer in uvcache:
                    (uv1, uv2, uv3, uv4) = layer[F.index]
                    a.append((uv1, uv2, uv3))
                    b.append((uv1, uv3, uv4))
            for (tidx, tri) in enumerate(tris):
                face = []
                for (vidx, idx) in enumerate(tri):
                    v = mesh.vertices[idx]
                    if smooth:
                        (nx, ny, nz) = swap(v.normal)
                    else:
                        (nx, ny, nz) = swap(F.normal)
                    r = 1.0
                    g = 1.0
                    b = 1.0
                    ra = 1.0
                    if vcolors:
                        k = list(F.vertices).index(idx)
                        (r, g, b) = getattr(vcolors.data[F.index], ('color%s' % (k + 1)))
                        if vcolors_alpha:
                            (ra, ga, ba) = getattr(vcolors_alpha.data[F.index], ('color%s' % (k + 1)))
                        else:
                            ra = 1.0
                    vert_uvs = []
                    if dotextures:
                        for layer in uvtris[tidx]:
                            vert_uvs.append(layer[vidx])
                    vert = VertexNoPos(numverts, nx, ny, nz, r, g, b, ra, vert_uvs)
                    alreadyExported = False
                    if (idx in _sm_vertices_):
                        for vert2 in _sm_vertices_[idx]:
                            if (vert == vert2):
                                face.append(vert2.ogre_vidx)
                                alreadyExported = True
                                break
                        if (not alreadyExported):
                            face.append(vert.ogre_vidx)
                            _sm_vertices_[idx].append(vert)
                    else:
                        face.append(vert.ogre_vidx)
                        _sm_vertices_[idx] = [vert]
                    if alreadyExported:
                        continue
                    numverts += 1
                    _remap_verts_.append(v)
                    (x, y, z) = swap(v.co)
                    doc.start_tag('vertex', {})
                    doc.leaf_tag('position', {'x': ('%6f' % x), 'y': ('%6f' % y), 'z': ('%6f' % z), })
                    doc.leaf_tag('normal', {'x': ('%6f' % nx), 'y': ('%6f' % ny), 'z': ('%6f' % nz), })
                    if vcolors:
                        doc.leaf_tag('colour_diffuse', {'value': ('%6f %6f %6f %6f' % (r, g, b, ra)), })
                    if dotextures:
                        for uv in vert_uvs:
                            doc.leaf_tag('texcoord', {'u': ('%6f' % uv[0]), 'v': ('%6f' % (1.0 - uv[1])), })
                    doc.end_tag('vertex')
                faces.append((face[0], face[1], face[2]))
        del _sm_vertices_
        Report.vertices += numverts
        doc.end_tag('vertexbuffer')
        doc.end_tag('sharedgeometry')
        print (' time: ', (time.time() - start))
        print '    writing submeshes'
        doc.start_tag('submeshes', {})
        for (matidx, mat) in enumerate(materials):
            if (not len(_sm_faces_[matidx])):
                Report.warnings.append(('BAD SUBMESH: %s' % ob.name))
                continue
            doc.start_tag('submesh', {'usesharedvertices': 'true', 'material': material_name(mat), 'use32bitindexes': str(bool((numverts > 65535))), })
            doc.start_tag('faces', {'count': str(len(_sm_faces_[matidx])), })
            for (fidx, (v1, v2, v3)) in enumerate(_sm_faces_[matidx]):
                doc.leaf_tag('face', {'v1': str(v1), 'v2': str(v2), 'v3': str(v3), })
            doc.end_tag('faces')
            doc.end_tag('submesh')
            Report.triangles += len(_sm_faces_[matidx])
        del _sm_faces_
        doc.end_tag('submeshes')
        doc.start_tag('submeshnames', {})
        for (matidx, mat) in enumerate(materials):
            doc.start_tag('submesh', {'name': material_name(mat), 'index': str(matidx), })
            doc.end_tag('submesh')
        doc.end_tag('submeshnames')
        arm = ob.find_armature()
        if arm:
            doc.leaf_tag('skeletonlink', {'name': ('%s.skeleton' % (force_name or ob.data.name)), })
            doc.start_tag('boneassignments', {})
            badverts = 0
            for (vidx, v) in enumerate(_remap_verts_):
                check = 0
                for vgroup in v.groups:
                    if (vgroup.weight > CONFIG['TRIM_BONE_WEIGHTS']):
                        bnidx = find_bone_index(copy, arm, vgroup.group)
                        if (bnidx is not None):
                            doc.leaf_tag('vertexboneassignment', {'vertexindex': str(vidx), 'boneindex': str(bnidx), 'weight': str(vgroup.weight), })
                            check += 1
                if (check > 4):
                    badverts += 1
                    print ('WARNING: vertex %s is in more than 4 vertex groups (bone weights)\n(this maybe Ogre incompatible)' % vidx)
            if badverts:
                Report.warnings.append(('%s has %s vertices weighted to too many bones (Ogre limits a vertex to 4 bones)\n[try increaseing the Trim-Weights threshold option]' % (mesh.name, badverts)))
            doc.end_tag('boneassignments')
        if (CONFIG['SHAPE_ANIM'] and ob.data.shape_keys and len(ob.data.shape_keys.key_blocks)):
            print '    writing shape keys'
            doc.start_tag('poses', {})
            for (sidx, skey) in enumerate(ob.data.shape_keys.key_blocks):
                if (sidx == 0):
                    continue
                if (len(skey.data) != len(mesh.vertices)):
                    failure = 'FAILED to save shape animation - you can not use a modifier that changes the vertex count! '
                    failure += ('[ mesh : %s ]' % mesh.name)
                    Report.warnings.append(failure)
                    print failure
                    break
                doc.start_tag('pose', {'name': skey.name, 'target': 'mesh', })
                for (vidx, v) in enumerate(_remap_verts_):
                    pv = skey.data[v.index]
                    (x, y, z) = swap((pv.co - v.co))
                    doc.leaf_tag('poseoffset', {'x': ('%6f' % x), 'y': ('%6f' % y), 'z': ('%6f' % z), 'index': str(vidx), })
                doc.end_tag('pose')
            doc.end_tag('poses')
            if (ob.data.shape_keys.animation_data and len(ob.data.shape_keys.animation_data.nla_tracks)):
                print '    writing shape animations'
                doc.start_tag('animations', {})
                _fps = float(bpy.context.scene.render.fps)
                for nla in ob.data.shape_keys.animation_data.nla_tracks:
                    for (idx, strip) in enumerate(nla.strips):
                        doc.start_tag('animation', {'name': strip.name, 'length': str(((strip.frame_end - strip.frame_start) / _fps)), })
                        doc.start_tag('tracks', {})
                        doc.start_tag('track', {'type': 'pose', 'target': 'mesh', })
                        doc.start_tag('keyframes', {})
                        for frame in range(int(strip.frame_start), (int(strip.frame_end) + 1), bpy.context.scene.frame_step):
                            bpy.context.scene.frame_set(frame)
                            doc.start_tag('keyframe', {'time': str(((frame - strip.frame_start) / _fps)), })
                            for (sidx, skey) in enumerate(ob.data.shape_keys.key_blocks):
                                if (sidx == 0):
                                    continue
                                doc.leaf_tag('poseref', {'poseindex': str((sidx - 1)), 'influence': str(skey.value), })
                            doc.end_tag('keyframe')
                        doc.end_tag('keyframes')
                        doc.end_tag('track')
                        doc.end_tag('tracks')
                        doc.end_tag('animation')
                doc.end_tag('animations')
        if cleanup:
            bpy.data.objects.remove(copy)
            bpy.data.meshes.remove(mesh)
            mesh.user_clear()
            copy.user_clear()
            del copy
            del mesh
        del _remap_verts_
        del uvcache
        doc.close()
        f.close()

    def replaceInplace(f, searchExp, replaceExp):
        import fileinput
        for line in fileinput.input(f, inplace=1):
            if (searchExp in line):
                line = line.replace(searchExp, replaceExp)
            sys.stdout.write(line)
        fileinput.close()
    replaceInplace(xmlfile, ('__TO_BE_REPLACED_VERTEX_COUNT__' + '"'), (str(numverts) + '"'))
    del replaceInplace
    OgreXMLConverter(xmlfile, has_uvs=dotextures)
    if (arm and CONFIG['ARM_ANIM']):
        skel = Skeleton(ob)
        data = skel.to_xml()
        name = (force_name or ob.data.name)
        xmlfile = os.path.join(path, ('%s.skeleton.xml' % name))
        f = open(xmlfile, 'wb')
        f.write(bytes(data, 'utf-8'))
        f.close()
        OgreXMLConverter(xmlfile)
    mats = []
    for mat in materials:
        if (mat != '_missing_material_'):
            mats.append(mat)
    print ('*' * 80)
    print ('TIME: ', (time.time() - start))
    return mats
