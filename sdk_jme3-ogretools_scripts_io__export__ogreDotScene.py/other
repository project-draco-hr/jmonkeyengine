bl_info = {'name': 'OGRE Exporter (.scene, .mesh, .skeleton) and RealXtend (.txml)', 'author': 'Brett, S.Rombauts, F00bar, Waruck, Mind Calamity, Mr.Magne', 'version': (0, 5, 7), 'blender': (2, 6, 3), 'location': 'File > Export...', 'description': 'Export to Ogre xml and binary formats', 'wiki_url': 'http://code.google.com/p/blender2ogre/w/list', 'tracker_url': 'http://code.google.com/p/blender2ogre/issues/list', 'category': 'Import-Export', }
VERSION = '0.5.7 preview1'
UI_CLASSES = []
import os, sys, time, array, ctypes, math
try:
    import bpy, mathutils
    from bpy.props import *
except ImportError:
    assert (__name__ == '__main__')
    print 'Trying to compile Rpython C-library'
    assert (sys.version_info.major == 2)
    print '...searching for rpythonic...'
    sys.path.append('../rpythonic')
    import rpythonic
    rpythonic.set_pypy_root('../pypy')
    import pypy.rpython.lltypesystem.rffi as rffi
    from pypy.rlib import streamio
    rpy = rpythonic.RPython('blender2ogre')

    @rpy.bind(path=str, facesAddr=int, facesSmoothAddr=int, facesMatAddr=int, vertsPosAddr=int, vertsNorAddr=int, numFaces=int, numVerts=int, materialNames=str)
    def dotmesh(path, facesAddr, facesSmoothAddr, facesMatAddr, vertsPosAddr, vertsNorAddr, numFaces, numVerts, materialNames):
        print ('PATH----------------', path)
        materials = []
        for matname in materialNames.split(';'):
            print ('Material Name: %s' % matname)
            materials.append(matname)
        file = streamio.open_file_as_stream(path, 'w')
        faces = rffi.cast(rffi.UINTP, facesAddr)
        facesSmooth = rffi.cast(rffi.CCHARP, facesSmoothAddr)
        facesMat = rffi.cast(rffi.USHORTP, facesMatAddr)
        vertsPos = rffi.cast(rffi.FLOATP, vertsPosAddr)
        vertsNor = rffi.cast(rffi.FLOATP, vertsNorAddr)
        VB = ['<sharedgeometry>', '<vertexbuffer positions="true" normals="true">']
        fastlookup = {}
        ogre_vert_index = 0
        triangles = []
        for fidx in range(numFaces):
            smooth = ord(facesSmooth[fidx])
            matidx = facesMat[fidx]
            i = (fidx * 4)
            ai = faces[i]
            bi = faces[(i + 1)]
            ci = faces[(i + 2)]
            di = faces[(i + 3)]
            triangle = []
            for J in [ai, bi, ci]:
                i = (J * 3)
                x = rffi.cast(rffi.DOUBLE, vertsPos[i])
                y = rffi.cast(rffi.DOUBLE, vertsPos[(i + 1)])
                z = rffi.cast(rffi.DOUBLE, vertsPos[(i + 2)])
                pos = (x, y, z)
                x = rffi.cast(rffi.DOUBLE, vertsNor[i])
                y = rffi.cast(rffi.DOUBLE, vertsNor[(i + 1)])
                z = rffi.cast(rffi.DOUBLE, vertsNor[(i + 2)])
                nor = (x, y, z)
                SIG = (pos, nor)
                skip = False
                if (J in fastlookup):
                    for otherSIG in fastlookup[J]:
                        if (SIG == otherSIG):
                            triangle.append(fastlookup[J][otherSIG])
                            skip = True
                            break
                    if (not skip):
                        triangle.append(ogre_vert_index)
                        fastlookup[J][SIG] = ogre_vert_index
                else:
                    triangle.append(ogre_vert_index)
                    fastlookup[J] = {SIG: ogre_vert_index, }
                if skip:
                    continue
                xml = ['<vertex>', ('<position x="%s" y="%s" z="%s" />' % pos), ('<normal x="%s" y="%s" z="%s" />' % nor), '</vertex>']
                VB.append('\n'.join(xml))
                ogre_vert_index += 1
            triangles.append(triangle)
        VB.append('</vertexbuffer>')
        VB.append('</sharedgeometry>')
        file.write('\n'.join(VB))
        del VB
        SMS = ['<submeshes>']
        SM = [('<submesh usesharedvertices="true" use32bitindexes="true" material="%s">' % 'somemat'), ('<faces count="%s">' % '100')]
        for tri in triangles:
            assert isinstance(tri, tuple)
            s = ('<face v1="%s" v2="%s" v3="%s" />' % tri)
            SM.append(s)
        SM.append('</faces>')
        SM.append('</submesh>')
        file.write('\n'.join(SM))
        file.close()
    rpy.cache(refresh=1)
    sys.exit('OK: module compiled and cached')
import hashlib, getpass, tempfile, configparser, subprocess, pickle
from xml.sax.saxutils import XMLGenerator
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
if (SCRIPT_DIR not in sys.path):
    sys.path.append(SCRIPT_DIR)
bpy.types.Object.use_avatar = BoolProperty(name='enable avatar', description='enables EC_Avatar', default=False)
bpy.types.Object.avatar_reference = StringProperty(name='avatar reference', description='sets avatar reference URL', maxlen=128, default='')
BoolProperty(name='enable avatar', description='enables EC_Avatar', default=False)
bpy.types.Object.uid = IntProperty(name='unique ID', description='unique ID for Tundra', default=0, min=0, max=(2 ** 14))
bpy.types.Object.use_draw_distance = BoolProperty(name='enable draw distance', description='use LOD draw distance', default=False)
bpy.types.Object.draw_distance = FloatProperty(name='draw distance', description='distance at which to begin drawing object', default=0.0, min=0.0, max=10000.0)
bpy.types.Object.cast_shadows = BoolProperty(name='cast shadows', description='cast shadows', default=False)
bpy.types.Object.use_multires_lod = BoolProperty(name='Enable Multires LOD', description='enables multires LOD', default=False)
bpy.types.Object.multires_lod_range = FloatProperty(name='multires LOD range', description='far distance at which multires is set to base level', default=30.0, min=0.0, max=10000.0)
_physics_modes = [('NONE', 'NONE', 'no physics'), ('RIGID_BODY', 'RIGID_BODY', 'rigid body'), ('SOFT_BODY', 'SOFT_BODY', 'soft body')]
bpy.types.Object.physics_mode = EnumProperty(items=_physics_modes, name='physics mode', description='physics mode', default='NONE')
bpy.types.Object.physics_friction = FloatProperty(name='Simple Friction', description='physics friction', default=0.1, min=0.0, max=1.0)
bpy.types.Object.physics_bounce = FloatProperty(name='Simple Bounce', description='physics bounce', default=0.01, min=0.0, max=1.0)
bpy.types.Object.collision_terrain_x_steps = IntProperty(name='Ogre Terrain: x samples', description='resolution in X of height map', default=64, min=4, max=8192)
bpy.types.Object.collision_terrain_y_steps = IntProperty(name='Ogre Terrain: y samples', description='resolution in Y of height map', default=64, min=4, max=8192)
_collision_modes = [('NONE', 'NONE', 'no collision'), ('PRIMITIVE', 'PRIMITIVE', 'primitive collision type'), ('MESH', 'MESH', 'triangle-mesh or convex-hull collision type'), ('DECIMATED', 'DECIMATED', 'auto-decimated collision type'), ('COMPOUND', 'COMPOUND', 'children primitive compound collision type'), ('TERRAIN', 'TERRAIN', 'terrain (height map) collision type')]
bpy.types.Object.collision_mode = EnumProperty(items=_collision_modes, name='primary collision mode', description='collision mode', default='NONE')
bpy.types.Object.subcollision = BoolProperty(name='collision compound', description='member of a collision compound', default=False)
bpy.types.Speaker.play_on_load = BoolProperty(name='play on load', default=False)
bpy.types.Speaker.loop = BoolProperty(name='loop sound', default=False)
bpy.types.Speaker.use_spatial = BoolProperty(name='3D spatial sound', default=True)
_IMAGE_FORMATS = [('NONE', 'NONE', 'do not convert image'), ('bmp', 'bmp', 'bitmap format'), ('jpg', 'jpg', 'jpeg format'), ('gif', 'gif', 'gif format'), ('png', 'png', 'png format'), ('tga', 'tga', 'targa format'), ('dds', 'dds', 'nvidia dds format')]
bpy.types.Image.use_convert_format = BoolProperty(name='use convert format', default=False)
bpy.types.Image.convert_format = EnumProperty(items=_IMAGE_FORMATS, name='convert to format', description='converts to image format using imagemagick', default='NONE')
bpy.types.Image.jpeg_quality = IntProperty(name='jpeg quality', description='quality of jpeg', default=80, min=0, max=100)
bpy.types.Image.use_color_quantize = BoolProperty(name='use color quantize', default=False)
bpy.types.Image.use_color_quantize_dither = BoolProperty(name='use color quantize dither', default=True)
bpy.types.Image.color_quantize = IntProperty(name='color quantize', description='reduce to N colors (requires ImageMagick)', default=32, min=2, max=256)
bpy.types.Image.use_resize_half = BoolProperty(name='resize by 1/2', default=False)
bpy.types.Image.use_resize_absolute = BoolProperty(name='force image resize', default=False)
bpy.types.Image.resize_x = IntProperty(name='resize X', description='only if image is larger than defined, use ImageMagick to resize it down', default=256, min=2, max=4096)
bpy.types.Image.resize_y = IntProperty(name='resize Y', description='only if image is larger than defined, use ImageMagick to resize it down', default=256, min=2, max=4096)
bpy.types.Material.ogre_depth_write = BoolProperty(name='depth write', default=True)
bpy.types.Material.ogre_depth_check = BoolProperty(name='depth check', default=True)
bpy.types.Material.ogre_alpha_to_coverage = BoolProperty(name='multisample alpha edges', default=False)
bpy.types.Material.ogre_light_scissor = BoolProperty(name='light scissor', default=False)
bpy.types.Material.ogre_light_clip_planes = BoolProperty(name='light clip planes', default=False)
bpy.types.Material.ogre_normalise_normals = BoolProperty(name='normalise normals', default=False, description="\nScaling objects causes normals to also change magnitude, which can throw off your lighting calculations. By default, the SceneManager detects this and will automatically re-normalise normals for any scaled object, but this has a cost. If you'd prefer to control this manually, call SceneManager::setNormaliseNormalsOnScale(false) and then use this option on materials which are sensitive to normals being resized.\n")
bpy.types.Material.ogre_lighting = BoolProperty(name='dynamic lighting', default=True)
bpy.types.Material.ogre_colour_write = BoolProperty(name='color-write', default=True)
bpy.types.Material.use_fixed_pipeline = BoolProperty(name='fixed pipeline', default=True)
bpy.types.Material.use_material_passes = BoolProperty(name='use ogre extra material passes (layers)', default=False)
bpy.types.Material.use_in_ogre_material_pass = BoolProperty(name='Layer Toggle', default=True)
bpy.types.Material.use_ogre_advanced_options = BoolProperty(name='Show Advanced Options', default=False)
bpy.types.Material.use_ogre_parent_material = BoolProperty(name='Use Script Inheritance', default=False)
bpy.types.Material.ogre_parent_material = EnumProperty(name='Script Inheritence', description='ogre parent material class', items=[])
bpy.types.Material.ogre_polygon_mode = EnumProperty(items=[('solid', 'solid', 'SOLID'), ('wireframe', 'wireframe', 'WIREFRAME'), ('points', 'points', 'POINTS')], name='faces draw type', description='ogre face draw mode', default='solid')
bpy.types.Material.ogre_shading = EnumProperty(items=[('flat', 'flat', 'FLAT'), ('gouraud', 'gouraud', 'GOURAUD'), ('phong', 'phong', 'PHONG')], name='hardware shading', description='Sets the kind of shading which should be used for representing dynamic lighting for this pass.', default='gouraud')
bpy.types.Material.ogre_cull_hardware = EnumProperty(items=[('clockwise', 'clockwise', 'CLOCKWISE'), ('anticlockwise', 'anticlockwise', 'COUNTER CLOCKWISE'), ('none', 'none', 'NONE')], name='hardware culling', description="If the option 'cull_hardware clockwise' is set, all triangles whose vertices are viewed in clockwise order from the camera will be culled by the hardware.", default='clockwise')
bpy.types.Material.ogre_transparent_sorting = EnumProperty(items=[('on', 'on', 'ON'), ('off', 'off', 'OFF'), ('force', 'force', 'FORCE ON')], name='transparent sorting', description="By default all transparent materials are sorted such that renderables furthest away from the camera are rendered first. This is usually the desired behaviour but in certain cases this depth sorting may be unnecessary and undesirable. If for example it is necessary to ensure the rendering order does not change from one frame to the next. In this case you could set the value to 'off' to prevent sorting.", default='on')
bpy.types.Material.ogre_illumination_stage = EnumProperty(items=[('', '', 'autodetect'), ('ambient', 'ambient', 'ambient'), ('per_light', 'per_light', 'lights'), ('decal', 'decal', 'decal')], name='illumination stage', description='When using an additive lighting mode (SHADOWTYPE_STENCIL_ADDITIVE or SHADOWTYPE_TEXTURE_ADDITIVE), the scene is rendered in 3 discrete stages, ambient (or pre-lighting), per-light (once per light, with shadowing) and decal (or post-lighting). Usually OGRE figures out how to categorise your passes automatically, but there are some effects you cannot achieve without manually controlling the illumination.', default='')
_ogre_depth_func = [('less_equal', 'less_equal', '<='), ('less', 'less', '<'), ('equal', 'equal', '=='), ('not_equal', 'not_equal', '!='), ('greater_equal', 'greater_equal', '>='), ('greater', 'greater', '>'), ('always_fail', 'always_fail', 'false'), ('always_pass', 'always_pass', 'true')]
bpy.types.Material.ogre_depth_func = EnumProperty(items=_ogre_depth_func, name='depth buffer function', description='If depth checking is enabled (see depth_check) a comparison occurs between the depth value of the pixel to be written and the current contents of the buffer. This comparison is normally less_equal, i.e. the pixel is written if it is closer (or at the same distance) than the current contents', default='less_equal')
_ogre_scene_blend_ops = [('add', 'add', 'DEFAULT'), ('subtract', 'subtract', 'SUBTRACT'), ('reverse_subtract', 'reverse_subtract', 'REVERSE SUBTRACT'), ('min', 'min', 'MIN'), ('max', 'max', 'MAX')]
bpy.types.Material.ogre_scene_blend_op = EnumProperty(items=_ogre_scene_blend_ops, name='scene blending operation', description='This directive changes the operation which is applied between the two components of the scene blending equation', default='add')
_ogre_scene_blend_types = [('one zero', 'one zero', 'DEFAULT'), ('alpha_blend', 'alpha_blend', "The alpha value of the rendering output is used as a mask. Equivalent to 'scene_blend src_alpha one_minus_src_alpha'"), ('add', 'add', "The colour of the rendering output is added to the scene. Good for explosions, flares, lights, ghosts etc. Equivalent to 'scene_blend one one'."), ('modulate', 'modulate', "The colour of the rendering output is multiplied with the scene contents. Generally colours and darkens the scene, good for smoked glass, semi-transparent objects etc. Equivalent to 'scene_blend dest_colour zero'"), ('colour_blend', 'colour_blend', 'Colour the scene based on the brightness of the input colours, but dont darken. Equivalent to "scene_blend src_colour one_minus_src_colour"')]
for mode in 'dest_colour src_colour one_minus_dest_colour dest_alpha src_alpha one_minus_dest_alpha one_minus_src_alpha'.split():
    _ogre_scene_blend_types.append((('one %s' % mode), ('one %s' % mode), ''))
del mode
bpy.types.Material.ogre_scene_blend = EnumProperty(items=_ogre_scene_blend_types, name='scene blend', description='blending operation of material to scene', default='one zero')
_faq_ = '\n\nQ: i have hundres of objects, is there a way i can merge them on export only?\nA: yes, just add them to a group named starting with "merge", or link the group.\n\nQ: can i use subsurf or multi-res on a mesh with an armature?\nA: yes.\n\nQ: can i use subsurf or multi-res on a mesh with shape animation?\nA: no.\n\nQ: i don\'t see any objects when i export?\nA: you must select the objects you wish to export.\n\nQ: i don\'t see my animations when exported?\nA: make sure you created an NLA strip on the armature.\n\nQ: do i need to bake my IK and other constraints into FK on my armature before export?\nA: no.\n\n'
_doc_installing_ = "\nInstalling:\n    Installing the Addon:\n        You can simply copy io_export_ogreDotScene.py to your blender installation under blender/2.60/scripts/addons/\n        and enable it in the user-prefs interface (CTRL+ALT+U)\n        Or you can use blenders interface, under user-prefs, click addons, and click 'install-addon'\n        (its a good idea to delete the old version first)\n\n    Required:\n        1. blender2.60\n\n        2. Install Ogre Command Line tools to the default path ( C:\\OgreCommandLineTools )\n            http://www.ogre3d.org/download/tools\n            (Linux users may use above and Wine, or install from source, or install via apt-get install ogre-tools)\n\n    Optional:\n        3. Install NVIDIA DDS Legacy Utilities    ( install to default path )\n            http://developer.nvidia.com/object/dds_utilities_legacy.html\n            (Linux users will need to use Wine)\n\n        4. Install Image Magick\n            http://www.imagemagick.org\n\n        5. Copy OgreMeshy to C:\\OgreMeshy\n            If your using 64bit Windows, you may need to download a 64bit OgreMeshy\n            (Linux copy to your home folder)\n\n        6. RealXtend Tundra2\n            http://blender2ogre.googlecode.com/files/realxtend-Tundra-2.1.2-OpenGL.7z\n            Windows: extract to C:\\Tundra2\n            Linux: extract to ~/Tundra2\n"
AXIS_MODES = [('xyz', 'xyz', 'no swapping'), ('xz-y', 'xz-y', 'ogre standard'), ('-xzy', '-xzy', 'non standard')]
CONFIG_PATH = bpy.utils.user_resource('CONFIG', path='scripts', create=True)
CONFIG_FILENAME = 'blender2ogre.pickle'
CONFIG_FILEPATH = os.path.join(CONFIG_PATH, CONFIG_FILENAME)
_CONFIG_DEFAULTS_ALL = {'TUNDRA_STREAMING': True, 'COPY_SHADER_PROGRAMS': True, 'MAX_TEXTURE_SIZE': 4096, 'SWAP_AXIS': 'xz-y', 'ONLY_ANIMATED_BONES': False, 'ONLY_DEFORMABLE_BONES': False, 'INDEPENDENT_ANIM': False, 'FORCE_IMAGE_FORMAT': 'NONE', 'TOUCH_TEXTURES': True, 'SEP_MATS': True, 'SCENE': True, 'SELONLY': True, 'FORCE_CAMERA': True, 'FORCE_LAMPS': True, 'MESH': True, 'MESH_OVERWRITE': True, 'ARM_ANIM': True, 'SHAPE_ANIM': True, 'ARRAY': True, 'MATERIALS': True, 'DDS_MIPS': True, 'TRIM_BONE_WEIGHTS': 0.01, 'lodLevels': 0, 'lodDistance': 300, 'lodPercent': 40, 'nuextremityPoints': 0, 'generateEdgeLists': False, 'generateTangents': True, 'tangentSemantic': 'uvw', 'tangentUseParity': 4, 'tangentSplitMirrored': False, 'tangentSplitRotated': False, 'reorganiseBuffers': True, 'optimiseAnimations': True, }
_CONFIG_TAGS_ = 'OGRETOOLS_XML_CONVERTER OGRETOOLS_MESH_MAGICK TUNDRA_ROOT OGRE_MESHY IMAGE_MAGICK_CONVERT NVCOMPRESS NVIDIATOOLS_EXE USER_MATERIALS SHADER_PROGRAMS TUNDRA_STREAMING'.split()
_CONFIG_DEFAULTS_WINDOWS = {'OGRETOOLS_XML_CONVERTER': 'C:\\OgreCommandLineTools\\OgreXmlConverter.exe', 'OGRETOOLS_MESH_MAGICK': 'C:\\OgreCommandLineTools\\MeshMagick.exe', 'TUNDRA_ROOT': 'C:\\Tundra2', 'OGRE_MESHY': 'C:\\OgreMeshy\\Ogre Meshy.exe', 'IMAGE_MAGICK_CONVERT': 'C:\\Program Files\\ImageMagick\\convert.exe', 'NVIDIATOOLS_EXE': 'C:\\Program Files\\NVIDIA Corporation\\DDS Utilities\\nvdxt.exe', 'USER_MATERIALS': 'C:\\Tundra2\\media\\materials', 'SHADER_PROGRAMS': 'C:\\Tundra2\\media\\materials\\programs', 'NVCOMPRESS': 'C:\\nvcompress.exe', }
_CONFIG_DEFAULTS_UNIX = {'OGRETOOLS_XML_CONVERTER': '/usr/local/bin/OgreXMLConverter', 'OGRETOOLS_MESH_MAGICK': '/usr/local/bin/MeshMagick', 'TUNDRA_ROOT': '~/Tundra2', 'OGRE_MESHY': '~/OgreMeshy/Ogre Meshy.exe', 'IMAGE_MAGICK_CONVERT': '/usr/bin/convert', 'NVIDIATOOLS_EXE': '~/.wine/drive_c/Program Files/NVIDIA Corporation/DDS Utilities', 'USER_MATERIALS': '~/Tundra2/media/materials', 'SHADER_PROGRAMS': '~/Tundra2/media/materials/programs', 'NVCOMPRESS': '/usr/local/bin/nvcompress', }
if (sys.platform.startswith('linux') or sys.platform.startswith('darwin') or sys.platform.startswith('freebsd')):
    for tag in _CONFIG_DEFAULTS_UNIX:
        path = _CONFIG_DEFAULTS_UNIX[tag]
        if path.startswith('~'):
            _CONFIG_DEFAULTS_UNIX[tag] = os.path.expanduser(path)
        elif (tag.startswith('OGRETOOLS') and (not os.path.isfile(path))):
            _CONFIG_DEFAULTS_UNIX[tag] = os.path.join('/usr/bin', os.path.split(path)[(-1)])
    del tag
    del path
CONFIG = {}
CONFIG = load_config()
MISSING_MATERIAL = '\nmaterial _missing_material_ \n{\n    receive_shadows off\n    technique\n    {\n        pass\n        {\n            ambient 0.1 0.1 0.1 1.0\n            diffuse 0.8 0.0 0.0 1.0\n            specular 0.5 0.5 0.5 1.0 12.5\n            emissive 0.3 0.3 0.3 1.0\n        }\n    }\n}\n'
Report = ReportSingleton()
_game_logic_intro_doc_ = '\nHijacking the BGE\n\nBlender contains a fully functional game engine (BGE) that is highly useful for learning the concepts of game programming by breaking it down into three simple parts: Sensor, Controller, and Actuator.  An Ogre based game engine will likely have similar concepts in its internal API and game logic scripting.  Without a custom interface to define game logic, very often game designers may have to resort to having programmers implement their ideas in purely handwritten script.  This is prone to breakage because object names then end up being hard-coded.  Not only does this lead to non-reusable code, its also a slow process.  Why should we have to resort to this when Blender already contains a very rich interface for game logic?  By hijacking a subset of the BGE interface we can make this workflow between game designer and game programmer much better.\n\nThe OgreDocScene format can easily be extened to include extra game logic data.  While the BGE contains some features that can not be easily mapped to other game engines, there are many are highly useful generic features we can exploit, including many of the Sensors and Actuators.  Blender uses the paradigm of: 1. Sensor -> 2. Controller -> 3. Actuator.  In pseudo-code, this can be thought of as: 1. on-event -> 2. conditional logic -> 3. do-action.  The designer is most often concerned with the on-events (the Sensors), and the do-actions (the Actuators); and the BGE interface provides a clear way for defining and editing those.  Its a harder task to provide a good interface for the conditional logic (Controller), that is flexible enough to fit everyones different Ogre engine and requirements, so that is outside the scope of this exporter at this time.  A programmer will still be required to fill the gap between Sensor and Actuator, but hopefully his work is greatly reduced and can write more generic/reuseable code.\n\nThe rules for which Sensors trigger which Actuators is left undefined, as explained above we are hijacking the BGE interface not trying to export and reimplement everything.  BGE Controllers and all links are ignored by the exporter, so whats the best way to define Sensor/Actuator relationships?  One convention that seems logical is to group Sensors and Actuators by name.  More complex syntax could be used in Sensor/Actuators names, or they could be completely ignored and instead all the mapping is done by the game programmer using other rules.  This issue is not easily solved so designers and the engine programmers will have to decide upon their own conventions, there is no one size fits all solution.\n'
_ogre_logic_types_doc_ = '\nSupported Sensors:\n    . Collision\n    . Near\n    . Radar\n    . Touching\n    . Raycast\n    . Message\n\nSupported Actuators:\n    . Shape Action*\n    . Edit Object\n    . Camera\n    . Constraint\n    . Message\n    . Motion\n    . Sound\n    . Visibility\n\n*note: Shape Action\nThe most common thing a designer will want to do is have an event trigger an animation.  The BGE contains an Actuator called "Shape Action", with useful properties like: start/end frame, and blending.  It also contains a property called "Action" but this is hidden because the exporter ignores action names and instead uses the names of NLA strips when exporting Ogre animation tracks.  The current workaround is to hijack the "Frame Property" attribute and change its name to "animation".  The designer can then simply type the name of the animation track (NLA strip).  Any custom syntax could actually be implemented here for calling animations, its up to the engine programmer to define how this field will be used.  For example: "*.explode" could be implemented to mean "on all objects" play the "explode" animation.\n\n'
_OGRE_DOCS_ = []
_ogre_command_line_tools_doc = "\nUsage: OgreXMLConverter [options] sourcefile [destfile] \n\nAvailable options:\n-i             = interactive mode - prompt for options\n(The next 4 options are only applicable when converting XML to Mesh)\n-l lodlevels   = number of LOD levels\n-v lodvalue     = value increment to reduce LOD\n-s lodstrategy = LOD strategy to use for this mesh\n-p lodpercent  = Percentage triangle reduction amount per LOD\n-f lodnumtris  = Fixed vertex reduction per LOD\n-e             = DON'T generate edge lists (for stencil shadows)\n-r             = DON'T reorganise vertex buffers to OGRE recommended format.\n-t             = Generate tangents (for normal mapping)\n-td [uvw|tangent]\n           = Tangent vertex semantic destination (default tangent)\n-ts [3|4]      = Tangent size (3 or 4 components, 4 includes parity, default 3)\n-tm            = Split tangent vertices at UV mirror points\n-tr            = Split tangent vertices where basis is rotated > 90 degrees\n-o             = DON'T optimise out redundant tracks & keyframes\n-d3d           = Prefer D3D packed colour formats (default on Windows)\n-gl            = Prefer GL packed colour formats (default on non-Windows)\n-E endian      = Set endian mode 'big' 'little' or 'native' (default)\n-x num         = Generate no more than num eXtremes for every submesh (default 0)\n-q             = Quiet mode, less output\n-log filename  = name of the log file (default: 'OgreXMLConverter.log')\nsourcefile     = name of file to convert\ndestfile       = optional name of file to write to. If you don't\n                 specify this OGRE works it out through the extension \n                 and the XML contents if the source is XML. For example\n                 test.mesh becomes test.xml, test.xml becomes test.mesh \n                 if the XML document root is <mesh> etc.\n"
NVDXT_DOC = "\nVersion 8.30\nNVDXT\nThis program\n   compresses images\n   creates normal maps from color or alpha\n   creates DuDv map\n   creates cube maps\n   writes out .dds file\n   does batch processing\n   reads .tga, .bmp, .gif, .ppm, .jpg, .tif, .cel, .dds, .png, .psd, .rgb, *.bw and .rgba\n   filters MIP maps\n\nOptions:\n  -profile <profile name> : Read a profile created from the Photoshop plugin\n  -quick : use fast compression method\n  -quality_normal : normal quality compression\n  -quality_production : production quality compression\n  -quality_highest : highest quality compression (this can be very slow)\n  -rms_threshold <int> : quality RMS error. Above this, an extensive search is performed.\n  -prescale <int> <int>: rescale image to this size first\n  -rescale <nearest | hi | lo | next_lo>: rescale image to nearest, next highest or next lowest power of two\n  -rel_scale <float, float> : relative scale of original image. 0.5 is half size Default 1.0, 1.0\n\nOptional Filtering for rescaling. Default cube filter:\n  -RescalePoint\n  -RescaleBox\n  -RescaleTriangle\n  -RescaleQuadratic\n  -RescaleCubic\n  -RescaleCatrom\n  -RescaleMitchell\n  -RescaleGaussian\n  -RescaleSinc\n  -RescaleBessel\n  -RescaleHanning\n  -RescaleHamming\n  -RescaleBlackman\n  -RescaleKaiser\n  -clamp <int, int> : maximum image size. image width and height are clamped\n  -clampScale <int, int> : maximum image size. image width and height are scaled \n  -window <left, top, right, bottom> : window of original window to compress\n  -nomipmap : don't generate MIP maps\n  -nmips <int> : specify the number of MIP maps to generate\n  -rgbe : Image is RGBE format\n  -dither : add dithering\n  -sharpenMethod <method>: sharpen method MIP maps\n  <method> is \n        None\n        Negative\n        Lighter\n        Darker\n        ContrastMore\n        ContrastLess\n        Smoothen\n        SharpenSoft\n        SharpenMedium\n        SharpenStrong\n        FindEdges\n        Contour\n        EdgeDetect\n        EdgeDetectSoft\n        Emboss\n        MeanRemoval\n        UnSharp <radius, amount, threshold>\n        XSharpen <xsharpen_strength, xsharpen_threshold>\n        Custom\n  -pause : wait for keyboard on error\n  -flip : flip top to bottom \n  -timestamp : Update only changed files\n  -list <filename> : list of files to convert\n  -cubeMap : create cube map . \n            Cube faces specified with individual files with -list option\n                  positive x, negative x, positive y, negative y, positive z, negative z\n                  Use -output option to specify filename\n            Cube faces specified in one file.  Use -file to specify input filename\n\n  -volumeMap : create volume texture. \n            Volume slices specified with individual files with -list option\n                  Use -output option to specify filename\n            Volume specified in one file.  Use -file to specify input filename\n\n  -all : all image files in current directory\n  -outdir <directory>: output directory\n  -deep [directory]: include all subdirectories\n  -outsamedir : output directory same as input\n  -overwrite : if input is .dds file, overwrite old file\n  -forcewrite : write over readonly files\n  -file <filename> : input file to process. Accepts wild cards\n  -output <filename> : filename to write to [-outfile can also be specified]\n  -append <filename_append> : append this string to output filename\n  -8  <dxt1c | dxt1a | dxt3 | dxt5 | u1555 | u4444 | u565 | u8888 | u888 | u555 | L8 | A8>  : compress 8 bit images with this format\n  -16 <dxt1c | dxt1a | dxt3 | dxt5 | u1555 | u4444 | u565 | u8888 | u888 | u555 | A8L8> : compress 16 bit images with this format\n  -24 <dxt1c | dxt1a | dxt3 | dxt5 | u1555 | u4444 | u565 | u8888 | u888 | u555> : compress 24 bit images with this format\n  -32 <dxt1c | dxt1a | dxt3 | dxt5 | u1555 | u4444 | u565 | u8888 | u888 | u555> : compress 32 bit images with this format\n\n  -swapRB : swap rb\n  -swapRG : swap rg\n  -gamma <float value>: gamma correcting during filtering\n  -outputScale <float, float, float, float>: scale the output by this (r,g,b,a)\n  -outputBias <float, float, float, float>: bias the output by this amount (r,g,b,a)\n  -outputWrap : wraps overflow values modulo the output format \n  -inputScale <float, float, float, float>: scale the inpput by this (r,g,b,a)\n  -inputBias <float, float, float, float>: bias the input by this amount (r,g,b,a)\n  -binaryalpha : treat alpha as 0 or 1\n  -alpha_threshold <byte>: [0-255] alpha reference value \n  -alphaborder : border images with alpha = 0\n  -alphaborderLeft : border images with alpha (left) = 0\n  -alphaborderRight : border images with alpha (right)= 0\n  -alphaborderTop : border images with alpha (top) = 0\n  -alphaborderBottom : border images with alpha (bottom)= 0\n  -fadeamount <int>: percentage to fade each MIP level. Default 15\n\n  -fadecolor : fade map (color, normal or DuDv) over MIP levels\n  -fadetocolor <hex color> : color to fade to\n  -custom_fade <n> <n fadeamounts> : set custom fade amount.  n is number number of fade amounts. fadeamount are [0,1]\n  -fadealpha : fade alpha over MIP levels\n  -fadetoalpha <byte>: [0-255] alpha to fade to\n  -border : border images with color\n  -bordercolor <hex color> : color for border\n  -force4 : force DXT1c to use always four colors\n  -weight <float, float, float>: Compression weightings for R G and B\n  -luminance :  convert color values to luminance for L8 formats\n  -greyScale : Convert to grey scale\n  -greyScaleWeights <float, float, float, float>: override greyscale conversion weights of (0.3086, 0.6094, 0.0820, 0)  \n  -brightness <float, float, float, float>: per channel brightness. Default 0.0  usual range [0,1]\n  -contrast <float, float, float, float>: per channel contrast. Default 1.0  usual range [0.5, 1.5]\n\nTexture Format  Default DXT3:\n  -dxt1c   : DXT1 (color only)\n  -dxt1a   : DXT1 (one bit alpha)\n  -dxt3    : DXT3\n  -dxt5    : DXT5n\n  -u1555   : uncompressed 1:5:5:5\n  -u4444   : uncompressed 4:4:4:4\n  -u565    : uncompressed 5:6:5\n  -u8888   : uncompressed 8:8:8:8\n  -u888    : uncompressed 0:8:8:8\n  -u555    : uncompressed 0:5:5:5\n  -p8c     : paletted 8 bit (256 colors)\n  -p8a     : paletted 8 bit (256 colors with alpha)\n  -p4c     : paletted 4 bit (16 colors)\n  -p4a     : paletted 4 bit (16 colors with alpha)\n  -a8      : 8 bit alpha channel\n  -cxv8u8  : normal map format\n  -v8u8    : EMBM format (8, bit two component signed)\n  -v16u16  : EMBM format (16 bit, two component signed)\n  -A8L8    : 8 bit alpha channel, 8 bit luminance\n  -fp32x4  : fp32 four channels (A32B32G32R32F)\n  -fp32    : fp32 one channel (R32F)\n  -fp16x4  : fp16 four channels (A16B16G16R16F)\n  -dxt5nm  : dxt5 style normal map\n  -3Dc     : 3DC\n  -g16r16  : 16 bit in, two component\n  -g16r16f : 16 bit float, two components\n\nMip Map Filtering Options. Default box filter:\n  -Point\n  -Box\n  -Triangle\n  -Quadratic\n  -Cubic\n  -Catrom\n  -Mitchell\n  -Gaussian\n  -Sinc\n  -Bessel\n  -Hanning\n  -Hamming\n  -Blackman\n  -Kaiser\n\n***************************\nTo make a normal or dudv map, specify one of\n  -n4 : normal map 4 sample\n  -n3x3 : normal map 3x3 filter\n  -n5x5 : normal map 5x5 filter\n  -n7x7 : normal map 7x7 filter\n  -n9x9 : normal map 9x9 filter\n  -dudv : DuDv\n\nand source of height info:\n  -alpha : alpha channel\n  -rgb : average rgb\n  -biased : average rgb biased\n  -red : red channel\n  -green : green channel\n  -blue : blue channel\n  -max : max of (r,g,b)\n  -colorspace : mix of r,g,b\n\n-norm : normalize mip maps (source is a normal map)\n\n-toHeight : create a height map (source is a normal map)\n\n\nNormal/DuDv Map dxt:\n  -aheight : store calculated height in alpha field\n  -aclear : clear alpha channel\n  -awhite : set alpha channel = 1.0\n  -scale <float> : scale of height map. Default 1.0\n  -wrap : wrap texture around. Default off\n  -minz <int> : minimum value for up vector [0-255]. Default 0\n\n***************************\nTo make a depth sprite, specify:\n  -depth\n\nand source of depth info:\n  -alpha  : alpha channel\n  -rgb    : average rgb (default)\n  -red    : red channel\n  -green  : green channel\n  -blue   : blue channel\n  -max    : max of (r,g,b)\n  -colorspace : mix of r,g,b\n\nDepth Sprite dxt:\n  -aheight : store calculated depth in alpha channel\n  -aclear : store 0.0 in alpha channel\n  -awhite : store 1.0 in alpha channel\n  -scale <float> : scale of depth sprite (default 1.0)\n  -alpha_modulate : multiplies color by alpha during filtering\n  -pre_modulate : multiplies color by alpha before processing\n\nExamples\n  nvdxt -cubeMap -list cubemapfile.lst -output cubemap.dds\n  nvdxt -cubeMap -file cubemapfile.tga\n  nvdxt -file test.tga -dxt1c\n  nvdxt -file *.tga\n  nvdxt -file c:\temp\\*.tga\n  nvdxt -file temp\\*.tga\n  nvdxt -file height_field_in_alpha.tga -n3x3 -alpha -scale 10 -wrap\n  nvdxt -file grey_scale_height_field.tga -n5x5 -rgb -scale 1.3\n  nvdxt -file normal_map.tga -norm\n  nvdxt -file image.tga -dudv -fade -fadeamount 10\n  nvdxt -all -dxt3 -gamma -outdir .\\dds_dir -time\n  nvdxt -file *.tga -depth -max -scale 0.5\n\n"
try:
    import io_export_rogremesh.rogremesh as Rmesh
except:
    Rmesh = None
    print 'WARNING: "io_export_rogremesh" is missing'
if (Rmesh and Rmesh.rpy.load()):
    _USE_RPYTHON_ = True
else:
    _USE_RPYTHON_ = False
    print 'Rpython module is not cached, you must exit Blender to compile the module:'
    print 'cd io_export_rogremesh; python rogremesh.py'
TundraSingleton = None
STREAM_PROTO = _create_stream_proto()
STREAM_BUFFER_SIZE = 2048
TUNDRA_SCRIPT = ("\n# this file was generated by blender2ogre #\nimport tundra, socket, select, pickle\nSTREAM_BUFFER_SIZE = 2048\nglobals().update( %s )\nE = {}    # this is just for debugging from the pyconsole\n\ndef get_entity(ID):\n    scn = tundra.Scene().MainCameraScene()\n    return scn.GetEntityRaw( ID )\n\nclass Client(object):\n    def __init__(self):\n        self.socket = sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        host='localhost'; port = 9420\n        sock.bind((host, port))\n        self._animated = {}    # entity ID : { anim-name : weight }\n\n    def update(self, delay):\n        global E\n        sock = self.socket\n        poll = select.select( [ sock ], [], [], 0.01 )\n        if not poll[0]: return True\n        data = sock.recv( STREAM_BUFFER_SIZE )\n        assert len(data) == STREAM_BUFFER_SIZE\n        if not data:\n            print( 'blender crashed?' )\n            return\n        header = data[ : 4]\n        s = data[ 4 : int(header)+4 ]\n        objects = pickle.loads( s )\n        scn = tundra.Scene().MainCameraScene()\t# replaces GetDefaultScene()\n        for ob in objects:\n            e = scn.GetEntityRaw( ob[ID] )\n            if not e: continue\n            x,y,z = ob[POSITION]\n            e.placeable.SetPosition( x,y,z )\n            x,y,z = ob[SCALE]\n            e.placeable.SetScale( x,y,z )\n            #e.placeable.SetOrientation( ob[ROTATION] )\n\n            if ob[TYPE] == LAMP:\n                e.light.range = ob[ DISTANCE ]\n                e.light.brightness = ob[ ENERGY ]\n                #e.light.diffColor = !! not wrapped !!\n                #e.light.specColor = !! not wrapped !!\n            elif ob[TYPE] == SPEAKER:\n                e.sound.soundGain = ob[VOLUME]\n                #e.sound.soundInnerRadius = \n                #e.sound.soundOuterRadius = \n                if ob[MUTE]: e.sound.StopSound()\n                else: e.sound.PlaySound()   # tundra API needs sound.IsPlaying()\n\n            if ANIMATIONS in ob:\n                self.update_animation( e, ob )\n\n            if LOD in ob:\n                #print( 'LOD', ob[LOD] )\n                index = e.id + ob[LOD] + 1\n                for i in range(1,9):\n                    elod = get_entity( e.id + i )\n                    if elod:\n                        if elod.id == index and not elod.placeable.visible:\n                            elod.placeable.visible = True\n                        elif elod.id != index and elod.placeable.visible:\n                            elod.placeable.visible = False\n\n            if ob[ID] not in E: E[ ob[ID] ] = e\n\n    def update_animation( self, e, ob ):\n        if ob[ID] not in self._animated:\n            self._animated[ ob[ID] ] = {}\n        state = self._animated[ ob[ID] ]\n        ac = e.animationcontroller\n        for aname in ob[ ANIMATIONS ]:\n            if aname not in state:      # save weight of new animation\n                state[ aname ] = ob[ANIMATIONS][aname]  # weight\n        for aname in state:\n            if aname not in ob[ANIMATIONS] and ac.IsAnimationActive( aname ):\n                ac.StopAnim( aname, '0.0' )\n            elif aname in ob[ANIMATIONS]:\n                weight = ob[ANIMATIONS][aname]\n                if ac.HasAnimationFinished( aname ):\n                    ac.PlayLoopedAnim( aname, '1.0', 'false' )      # PlayAnim(...) TODO single playback\n                    ok = ac.SetAnimationWeight( aname, weight )\n                    state[ aname ] = weight\n\n                if weight != state[ aname ]:\n                    ok = ac.SetAnimationWeight( aname, weight )\n                    state[ aname ] = weight\n\nclient = Client()\ntundra.Frame().connect( 'Updated(float)', client.update )\nprint('blender2ogre plugin ok')\n" % STREAM_PROTO)
try:
    _header_ = bpy.types.INFO_HT_header
except:
    print '---blender2ogre addon enable---'
_USE_TUNDRA_ = False
_USE_JMONKEY_ = False
MyShaders = None
bpy.types.World.ogre_skyX = BoolProperty(name='enable sky', description='ogre sky', default=False)
bpy.types.World.ogre_skyX_time = FloatProperty(name='Time Multiplier', description='change speed of day/night cycle', default=0.3, min=0.0, max=5.0)
bpy.types.World.ogre_skyX_wind = FloatProperty(name='Wind Direction', description='change direction of wind', default=33.0, min=0.0, max=360.0)
bpy.types.World.ogre_skyX_volumetric_clouds = BoolProperty(name='volumetric clouds', description='toggle ogre volumetric clouds', default=True)
bpy.types.World.ogre_skyX_cloud_density_x = FloatProperty(name='Cloud Density X', description='change density of volumetric clouds on X', default=0.1, min=0.0, max=5.0)
bpy.types.World.ogre_skyX_cloud_density_y = FloatProperty(name='Cloud Density Y', description='change density of volumetric clouds on Y', default=1.0, min=0.0, max=5.0)
_nvcompress_doc = '\nusage: nvcompress [options] infile [outfile]\n\nInput options:\n  -color   \tThe input image is a color map (default).\n  -alpha     \tThe input image has an alpha channel used for transparency.\n  -normal  \tThe input image is a normal map.\n  -tonormal\tConvert input to normal map.\n  -clamp   \tClamp wrapping mode (default).\n  -repeat  \tRepeat wrapping mode.\n  -nomips  \tDisable mipmap generation.\n\nCompression options:\n  -fast    \tFast compression.\n  -nocuda  \tDo not use cuda compressor.\n  -rgb     \tRGBA format\n  -bc1     \tBC1 format (DXT1)\n  -bc1n    \tBC1 normal map format (DXT1nm)\n  -bc1a    \tBC1 format with binary alpha (DXT1a)\n  -bc2     \tBC2 format (DXT3)\n  -bc3     \tBC3 format (DXT5)\n  -bc3n    \tBC3 normal map format (DXT5nm)\n  -bc4     \tBC4 format (ATI1)\n  -bc5     \tBC5 format (3Dc/ATI2)\n'
if (__name__ == '__main__'):
    register()
