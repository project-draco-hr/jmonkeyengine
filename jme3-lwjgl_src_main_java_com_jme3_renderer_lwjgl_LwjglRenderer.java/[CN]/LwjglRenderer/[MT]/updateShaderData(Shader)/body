{
  int id=shader.getId();
  boolean needRegister=false;
  if (id == -1) {
    id=glCreateProgram();
    if (id == 0) {
      throw new RendererException("Invalid ID (" + id + ") received when trying to create shader program.");
    }
    shader.setId(id);
    needRegister=true;
  }
  for (  ShaderSource source : shader.getSources()) {
    if (source.isUpdateNeeded()) {
      updateShaderSourceData(source);
    }
    glAttachShader(id,source.getId());
  }
  if (ctxCaps.GL_EXT_gpu_shader4) {
    glBindFragDataLocationEXT(id,0,"outFragColor");
    for (int i=0; i < maxMRTFBOAttachs; i++) {
      glBindFragDataLocationEXT(id,i,"outFragData[" + i + "]");
    }
  }
  glLinkProgram(id);
  glGetProgram(id,GL_LINK_STATUS,intBuf1);
  boolean linkOK=intBuf1.get(0) == GL_TRUE;
  String infoLog=null;
  if (VALIDATE_SHADER || !linkOK) {
    glGetProgram(id,GL_INFO_LOG_LENGTH,intBuf1);
    int length=intBuf1.get(0);
    if (length > 3) {
      ByteBuffer logBuf=BufferUtils.createByteBuffer(length);
      glGetProgramInfoLog(id,null,logBuf);
      byte[] logBytes=new byte[length];
      logBuf.get(logBytes,0,length);
      infoLog=new String(logBytes);
    }
  }
  if (linkOK) {
    if (infoLog != null) {
      logger.log(Level.WARNING,"Shader linked successfully. Linker warnings: \n{0}",infoLog);
    }
 else {
      logger.fine("Shader linked successfully.");
    }
    shader.clearUpdateNeeded();
    if (needRegister) {
      objManager.registerObject(shader);
      statistics.onNewShader();
    }
 else {
      resetUniformLocations(shader);
    }
  }
 else {
    if (infoLog != null) {
      throw new RendererException("Shader failed to link, shader:" + shader + "\n"+ infoLog);
    }
 else {
      throw new RendererException("Shader failed to link, shader:" + shader + "\ninfo: <not provided>");
    }
  }
}
