{
  loadCapabilities();
  context.initialDrawBuf=glGetInteger(GL_DRAW_BUFFER);
  context.initialReadBuf=glGetInteger(GL_READ_BUFFER);
  glGetInteger(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS,intBuf16);
  vertexTextureUnits=intBuf16.get(0);
  logger.log(Level.FINER,"VTF Units: {0}",vertexTextureUnits);
  if (vertexTextureUnits > 0) {
    caps.add(Caps.VertexTextureFetch);
  }
  glGetInteger(GL_MAX_TEXTURE_IMAGE_UNITS,intBuf16);
  fragTextureUnits=intBuf16.get(0);
  logger.log(Level.FINER,"Texture Units: {0}",fragTextureUnits);
  glGetInteger(GL_MAX_VERTEX_UNIFORM_COMPONENTS,intBuf16);
  vertexUniforms=intBuf16.get(0);
  logger.log(Level.FINER,"Vertex Uniforms: {0}",vertexUniforms);
  glGetInteger(GL_MAX_FRAGMENT_UNIFORM_COMPONENTS,intBuf16);
  fragUniforms=intBuf16.get(0);
  logger.log(Level.FINER,"Fragment Uniforms: {0}",fragUniforms);
  glGetInteger(GL_MAX_VERTEX_ATTRIBS,intBuf16);
  vertexAttribs=intBuf16.get(0);
  logger.log(Level.FINER,"Vertex Attributes: {0}",vertexAttribs);
  glGetInteger(GL_SUBPIXEL_BITS,intBuf16);
  int subpixelBits=intBuf16.get(0);
  logger.log(Level.FINER,"Subpixel Bits: {0}",subpixelBits);
  glGetInteger(GL_MAX_ELEMENTS_VERTICES,intBuf16);
  maxVertCount=intBuf16.get(0);
  logger.log(Level.FINER,"Preferred Batch Vertex Count: {0}",maxVertCount);
  glGetInteger(GL_MAX_ELEMENTS_INDICES,intBuf16);
  maxTriCount=intBuf16.get(0);
  logger.log(Level.FINER,"Preferred Batch Index Count: {0}",maxTriCount);
  glGetInteger(GL_MAX_TEXTURE_SIZE,intBuf16);
  maxTexSize=intBuf16.get(0);
  logger.log(Level.FINER,"Maximum Texture Resolution: {0}",maxTexSize);
  glGetInteger(GL_MAX_CUBE_MAP_TEXTURE_SIZE,intBuf16);
  maxCubeTexSize=intBuf16.get(0);
  logger.log(Level.FINER,"Maximum CubeMap Resolution: {0}",maxCubeTexSize);
  if (hasExtension("GL_ARB_color_buffer_float") && hasExtension("GL_ARB_half_float_pixel")) {
    caps.add(Caps.FloatColorBuffer);
  }
  if (hasExtension("GL_ARB_depth_buffer_float")) {
    caps.add(Caps.FloatDepthBuffer);
  }
  if (caps.contains(Caps.OpenGL30)) {
    caps.add(Caps.PackedDepthStencilBuffer);
  }
  if (hasExtension("GL_ARB_draw_instanced") && hasExtension("GL_ARB_instanced_arrays")) {
    caps.add(Caps.MeshInstancing);
  }
  if (hasExtension("GL_ARB_texture_buffer_object")) {
    caps.add(Caps.TextureBuffer);
  }
  if (hasExtension("GL_ARB_texture_float") && hasExtension("GL_ARB_half_float_pixel")) {
    caps.add(Caps.FloatTexture);
  }
  if (hasExtension("GL_ARB_vertex_array_object") || caps.contains(Caps.OpenGL30)) {
    caps.add(Caps.VertexBufferArray);
  }
  if (hasExtension("GL_ARB_texture_non_power_of_two") || caps.contains(Caps.OpenGL30)) {
    caps.add(Caps.NonPowerOfTwoTextures);
  }
 else {
    logger.log(Level.WARNING,"Your graphics card does not " + "support non-power-of-2 textures. " + "Some features might not work.");
  }
  if (hasExtension("GL_EXT_texture_compression_s3tc")) {
    caps.add(Caps.TextureCompressionS3TC);
  }
  if (hasExtension("GL_ARB_ES3_compatibility")) {
    caps.add(Caps.TextureCompressionETC1);
  }
  if (hasExtension("GL_EXT_packed_float") || caps.contains(Caps.OpenGL30)) {
    caps.add(Caps.PackedFloatColorBuffer);
    if (hasExtension("GL_ARB_half_float_pixel")) {
      caps.add(Caps.PackedFloatTexture);
    }
  }
  if (hasExtension("GL_EXT_texture_array") || caps.contains(Caps.OpenGL30)) {
    caps.add(Caps.TextureArray);
  }
  if (hasExtension("GL_EXT_texture_shared_exponent") || caps.contains(Caps.OpenGL30)) {
    caps.add(Caps.SharedExponentTexture);
  }
  if (hasExtension("GL_EXT_texture_filter_anisotropic")) {
    caps.add(Caps.TextureFilterAnisotropic);
  }
  if (hasExtension("GL_EXT_framebuffer_object")) {
    caps.add(Caps.FrameBuffer);
    glGetInteger(GL_MAX_RENDERBUFFER_SIZE_EXT,intBuf16);
    maxRBSize=intBuf16.get(0);
    logger.log(Level.FINER,"FBO RB Max Size: {0}",maxRBSize);
    glGetInteger(GL_MAX_COLOR_ATTACHMENTS_EXT,intBuf16);
    maxFBOAttachs=intBuf16.get(0);
    logger.log(Level.FINER,"FBO Max renderbuffers: {0}",maxFBOAttachs);
    if (hasExtension("GL_EXT_framebuffer_blit")) {
      caps.add(Caps.FrameBufferBlit);
    }
    if (hasExtension("GL_EXT_framebuffer_multisample")) {
      caps.add(Caps.FrameBufferMultisample);
      glGetInteger(GL_MAX_SAMPLES_EXT,intBuf16);
      maxFBOSamples=intBuf16.get(0);
      logger.log(Level.FINER,"FBO Max Samples: {0}",maxFBOSamples);
    }
    if (hasExtension("GL_ARB_texture_multisample")) {
      caps.add(Caps.TextureMultisample);
      glGetInteger(GL_MAX_COLOR_TEXTURE_SAMPLES,intBuf16);
      maxColorTexSamples=intBuf16.get(0);
      logger.log(Level.FINER,"Texture Multisample Color Samples: {0}",maxColorTexSamples);
      glGetInteger(GL_MAX_DEPTH_TEXTURE_SAMPLES,intBuf16);
      maxDepthTexSamples=intBuf16.get(0);
      logger.log(Level.FINER,"Texture Multisample Depth Samples: {0}",maxDepthTexSamples);
    }
    glGetInteger(GL_MAX_DRAW_BUFFERS,intBuf16);
    maxMRTFBOAttachs=intBuf16.get(0);
    if (maxMRTFBOAttachs > 1) {
      caps.add(Caps.FrameBufferMRT);
      logger.log(Level.FINER,"FBO Max MRT renderbuffers: {0}",maxMRTFBOAttachs);
    }
  }
  if (hasExtension("GL_ARB_multisample")) {
    glGetInteger(GL_SAMPLE_BUFFERS_ARB,intBuf16);
    boolean available=intBuf16.get(0) != 0;
    glGetInteger(GL_SAMPLES_ARB,intBuf16);
    int samples=intBuf16.get(0);
    logger.log(Level.FINER,"Samples: {0}",samples);
    boolean enabled=glIsEnabled(GL_MULTISAMPLE_ARB);
    if (samples > 0 && available && !enabled) {
      glEnable(GL_MULTISAMPLE_ARB);
    }
    caps.add(Caps.Multisample);
  }
  if ((hasExtension("GL_ARB_framebuffer_sRGB") && hasExtension("GL_EXT_texture_sRGB")) || caps.contains(Caps.OpenGL30)) {
    caps.add(Caps.Srgb);
  }
  logger.log(Level.FINE,"Caps: {0}",caps);
}
