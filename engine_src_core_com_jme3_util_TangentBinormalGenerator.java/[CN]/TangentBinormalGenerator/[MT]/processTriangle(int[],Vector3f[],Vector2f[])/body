{
  Vector3f edge1=new Vector3f();
  Vector3f edge2=new Vector3f();
  Vector2f edge1uv=new Vector2f();
  Vector2f edge2uv=new Vector2f();
  Vector3f tangent=new Vector3f();
  Vector3f binormal=new Vector3f();
  Vector3f normal=new Vector3f();
  t[1].subtract(t[0],edge1uv);
  t[2].subtract(t[0],edge2uv);
  float det=edge1uv.x * edge2uv.y - edge1uv.y * edge2uv.x;
  boolean normalize=false;
  if (Math.abs(det) < ZERO_TOLERANCE) {
    det=1;
    normalize=true;
  }
  v[1].subtract(v[0],edge1);
  v[2].subtract(v[0],edge2);
  tangent.set(edge1);
  tangent.normalizeLocal();
  binormal.set(edge2);
  binormal.normalizeLocal();
  float factor=1 / det;
  tangent.x=(edge2uv.y * edge1.x - edge1uv.y * edge2.x) * factor;
  tangent.y=(edge2uv.y * edge1.y - edge1uv.y * edge2.y) * factor;
  tangent.z=(edge2uv.y * edge1.z - edge1uv.y * edge2.z) * factor;
  if (normalize)   tangent.normalizeLocal();
  binormal.x=(edge1uv.x * edge2.x - edge2uv.x * edge1.x) * factor;
  binormal.y=(edge1uv.x * edge2.y - edge2uv.x * edge1.y) * factor;
  binormal.z=(edge1uv.x * edge2.z - edge2uv.x * edge1.z) * factor;
  if (normalize)   binormal.normalizeLocal();
  tangent.cross(binormal,normal);
  normal.normalizeLocal();
  return new TriangleData(tangent,binormal,normal,index[0],index[1],index[2]);
}
