{
  int radiusStepsX=(int)(radius / ((Node)terrain).getLocalScale().x);
  int radiusStepsZ=(int)(radius / ((Node)terrain).getLocalScale().z);
  float xStepAmount=((Node)terrain).getLocalScale().x;
  float zStepAmount=((Node)terrain).getLocalScale().z;
  List<Vector2f> locs=new ArrayList<Vector2f>();
  List<Float> heights=new ArrayList<Float>();
  for (int z=-radiusStepsZ; z < radiusStepsZ; z++) {
    for (int x=-radiusStepsX; x < radiusStepsX; x++) {
      float locX=worldLoc.x + (x * xStepAmount);
      float locZ=worldLoc.z + (z * zStepAmount);
      if (ToolUtils.isInMesh(locX - worldLoc.x,locZ - worldLoc.z,radius,mesh)) {
        Vector2f terrainLoc=new Vector2f(locX,locZ);
        float center=terrain.getHeightmapHeight(terrainLoc);
        float left=terrain.getHeightmapHeight(new Vector2f(terrainLoc.x - 1,terrainLoc.y));
        float right=terrain.getHeightmapHeight(new Vector2f(terrainLoc.x + 1,terrainLoc.y));
        float up=terrain.getHeightmapHeight(new Vector2f(terrainLoc.x,terrainLoc.y + 1));
        float down=terrain.getHeightmapHeight(new Vector2f(terrainLoc.x,terrainLoc.y - 1));
        int count=1;
        float amount=center;
        if (!isNaN(left)) {
          amount+=left;
          count++;
        }
        if (!isNaN(right)) {
          amount+=right;
          count++;
        }
        if (!isNaN(up)) {
          amount+=up;
          count++;
        }
        if (!isNaN(down)) {
          amount+=down;
          count++;
        }
        amount/=count;
        float diff=amount - center;
        diff*=height;
        locs.add(terrainLoc);
        heights.add(diff);
      }
    }
  }
  undoLocs=locs;
  undoHeights=heights;
  terrain.adjustHeight(locs,heights);
  ((Node)terrain).updateModelBound();
}
