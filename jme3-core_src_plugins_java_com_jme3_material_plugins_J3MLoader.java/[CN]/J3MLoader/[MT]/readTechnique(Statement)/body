{
  isUseNodes=false;
  String[] split=techStat.getLine().split(whitespacePattern);
  if (split.length == 1) {
    String techniqueUniqueName=materialDef.getAssetName() + "@Default";
    technique=new TechniqueDef(null,techniqueUniqueName.hashCode());
  }
 else   if (split.length == 2) {
    String techName=split[1];
    String techniqueUniqueName=materialDef.getAssetName() + "@" + techName;
    technique=new TechniqueDef(techName,techniqueUniqueName.hashCode());
  }
 else {
    throw new IOException("Technique statement syntax incorrect");
  }
  for (  Statement statement : techStat.getContents()) {
    readTechniqueStatement(statement);
  }
  if (isUseNodes) {
    nodesLoaderDelegate.computeConditions();
    technique.setShaderFile(technique.hashCode() + "",technique.hashCode() + "","GLSL100","GLSL100");
  }
  if (shaderNames.containsKey(Shader.ShaderType.Vertex) && shaderNames.containsKey(Shader.ShaderType.Fragment)) {
    technique.setShaderFile(shaderNames,shaderLanguages);
  }
  technique.setShaderPrologue(createShaderPrologue(presetDefines));
switch (technique.getLightMode()) {
case Disable:
    technique.setLogic(new DefaultTechniqueDefLogic(technique));
  break;
case MultiPass:
technique.setLogic(new MultiPassLightingLogic(technique));
break;
case SinglePass:
technique.setLogic(new SinglePassLightingLogic(technique));
break;
default :
throw new UnsupportedOperationException();
}
materialDef.addTechniqueDef(technique);
technique=null;
shaderLanguages.clear();
shaderNames.clear();
presetDefines.clear();
}
