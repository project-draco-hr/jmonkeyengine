{
  name=structure.getName();
  int mode=((Number)structure.getFieldValue("mode")).intValue();
  shadeless=(mode & 0x4) != 0;
  vertexColor=(mode & 0x80) != 0;
  vTangent=(mode & 0x4000000) != 0;
  int diff_shader=((Number)structure.getFieldValue("diff_shader")).intValue();
  diffuseShader=DiffuseShader.values()[diff_shader];
  if (this.shadeless) {
    diffuseColor=ColorRGBA.White.clone();
    specularShader=null;
    specularColor=ambientColor=null;
    shininess=0.0f;
  }
 else {
    diffuseColor=this.readDiffuseColor(structure,diffuseShader);
    int spec_shader=((Number)structure.getFieldValue("spec_shader")).intValue();
    specularShader=SpecularShader.values()[spec_shader];
    specularColor=this.readSpecularColor(structure,specularShader);
    float r=((Number)structure.getFieldValue("ambr")).floatValue();
    float g=((Number)structure.getFieldValue("ambg")).floatValue();
    float b=((Number)structure.getFieldValue("ambb")).floatValue();
    float alpha=((Number)structure.getFieldValue("alpha")).floatValue();
    ambientColor=new ColorRGBA(r,g,b,alpha);
    float shininess=((Number)structure.getFieldValue("emit")).floatValue();
    this.shininess=shininess > 0.0f ? shininess : MaterialHelper.DEFAULT_SHININESS;
  }
  float[] diffuseColorArray=new float[]{diffuseColor.r,diffuseColor.g,diffuseColor.b,diffuseColor.a};
  mTexs=new ArrayList<Structure>();
  textures=new ArrayList<Structure>();
  DynamicArray<Pointer> mtexsArray=(DynamicArray<Pointer>)structure.getFieldValue("mtex");
  int separatedTextures=((Number)structure.getFieldValue("septex")).intValue();
  Type firstTextureType=null;
  for (int i=0; i < mtexsArray.getTotalSize(); ++i) {
    Pointer p=mtexsArray.get(i);
    if (p.isNotNull() && (separatedTextures & 1 << i) == 0) {
      Structure mtex=p.fetchData(blenderContext.getInputStream()).get(0);
      if (uvCoordinatesType == -1) {
        uvCoordinatesType=((Number)mtex.getFieldValue("texco")).intValue();
        projectionType=((Number)mtex.getFieldValue("mapping")).intValue();
      }
 else       if (uvCoordinatesType != ((Number)mtex.getFieldValue("texco")).intValue()) {
        LOGGER.log(Level.WARNING,"The texture with index: {0} has different UV coordinates type than the first texture! This texture will NOT be loaded!",i + 1);
        continue;
      }
      Pointer pTex=(Pointer)mtex.getFieldValue("tex");
      if (pTex.isNotNull()) {
        Structure tex=pTex.fetchData(blenderContext.getInputStream()).get(0);
        int type=((Number)tex.getFieldValue("type")).intValue();
        Type textureType=this.getType(type);
        if (textureType != null) {
          if (firstTextureType == null) {
            firstTextureType=textureType;
            mTexs.add(mtex);
            textures.add(tex);
          }
 else           if (firstTextureType == textureType) {
            mTexs.add(mtex);
            textures.add(tex);
          }
 else {
            LOGGER.log(Level.WARNING,"The texture with index: {0} is of different dimension than the first one! This texture will NOT be loaded!",i + 1);
          }
        }
      }
    }
  }
  Map<Number,List<Structure[]>> sortedTextures=this.sortAndFilterTextures();
  loadedTextures=new HashMap<Number,Texture>(sortedTextures.size());
  textureToMTexMap=new HashMap<Texture,Structure>();
  TextureHelper textureHelper=blenderContext.getHelper(TextureHelper.class);
  for (  Entry<Number,List<Structure[]>> entry : sortedTextures.entrySet()) {
    if (entry.getValue().size() > 0) {
      List<Texture> textures=new ArrayList<Texture>(entry.getValue().size());
      for (      Structure[] mtexAndTex : entry.getValue()) {
        int texflag=((Number)mtexAndTex[0].getFieldValue("texflag")).intValue();
        boolean negateTexture=(texflag & 0x04) != 0;
        Texture texture=textureHelper.getTexture(mtexAndTex[1],blenderContext);
        int blendType=((Number)mtexAndTex[0].getFieldValue("blendtype")).intValue();
        float[] color=new float[]{((Number)mtexAndTex[0].getFieldValue("r")).floatValue(),((Number)mtexAndTex[0].getFieldValue("g")).floatValue(),((Number)mtexAndTex[0].getFieldValue("b")).floatValue()};
        float colfac=((Number)mtexAndTex[0].getFieldValue("colfac")).floatValue();
        texture=textureHelper.blendTexture(diffuseColorArray,texture,color,colfac,blendType,negateTexture,blenderContext);
        texture.setWrap(WrapMode.Repeat);
        textures.add(texture);
        textureToMTexMap.put(texture,mtexAndTex[0]);
      }
      loadedTextures.put(entry.getKey(),textureHelper.mergeTextures(textures,this));
    }
  }
  this.texturesCount=mTexs.size();
  this.textureType=firstTextureType;
  boolean transparent=false;
  if (diffuseColor != null) {
    transparent=diffuseColor.a < 1.0f;
  }
  if (specularColor != null) {
    transparent=transparent || specularColor.a < 1.0f;
  }
  if (ambientColor != null) {
    transparent=transparent || ambientColor.a < 1.0f;
  }
  this.transparent=transparent;
}
