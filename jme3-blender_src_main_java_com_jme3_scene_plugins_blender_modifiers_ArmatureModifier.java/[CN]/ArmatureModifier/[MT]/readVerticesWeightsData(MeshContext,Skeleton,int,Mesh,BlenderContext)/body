{
  int vertexListSize=meshContext.getVertexCount(materialIndex);
  Map<Integer,List<Integer>> vertexReferenceMap=meshContext.getVertexReferenceMap(materialIndex);
  Map<String,VertexGroup> vertexGroups=new HashMap<String,VertexGroup>();
  Buffer indexes=mesh.getBuffer(Type.Index).getData();
  FloatBuffer positions=mesh.getFloatBuffer(Type.Position);
  int maximumWeightsPerVertex=0;
  if (useVertexGroups) {
    LOGGER.fine("Attaching verts to bones using vertex groups.");
    for (int boneIndex=1; boneIndex < skeleton.getBoneCount(); ++boneIndex) {
      Bone bone=skeleton.getBone(boneIndex);
      VertexGroup vertexGroup=meshContext.getGroup(bone.getName());
      if (vertexGroup != null) {
        vertexGroup.setBoneIndex(boneIndex);
        vertexGroups.put(bone.getName(),vertexGroup);
      }
    }
  }
  if (useBoneEnvelopes) {
    LOGGER.fine("Attaching verts to bones using bone envelopes.");
    Vector3f pos=new Vector3f();
    for (int boneIndex=1; boneIndex < skeleton.getBoneCount(); ++boneIndex) {
      Bone bone=skeleton.getBone(boneIndex);
      BoneContext boneContext=blenderContext.getBoneContext(bone);
      BoneEnvelope boneEnvelope=boneContext.getBoneEnvelope();
      if (boneEnvelope != null) {
        VertexGroup vertexGroup=vertexGroups.get(bone.getName());
        if (vertexGroup == null) {
          vertexGroup=new VertexGroup();
          vertexGroups.put(bone.getName(),vertexGroup);
        }
        vertexGroup.setBoneIndex(boneIndex);
        for (        Entry<Integer,List<Integer>> entry : vertexReferenceMap.entrySet()) {
          List<Integer> vertexIndices=entry.getValue();
          for (int j=0; j < indexes.limit(); ++j) {
            int index=indexes instanceof ShortBuffer ? ((ShortBuffer)indexes).get(j) : ((IntBuffer)indexes).get(j);
            if (vertexIndices.contains(index)) {
              int ii=index * 3;
              pos.set(positions.get(ii),positions.get(ii + 1),positions.get(ii + 2));
              objectWorldMatrix.mult(pos,pos);
              if (boneEnvelope.isInEnvelope(pos)) {
                vertexGroup.addVertex(index,boneEnvelope.getWeight());
              }
 else               if (boneIndex == 5) {
                System.out.println("Si nie zaapa: " + pos);
              }
            }
          }
        }
      }
    }
  }
  Map<Integer,WeightsAndBoneIndexes> weights=new HashMap<Integer,WeightsAndBoneIndexes>();
  if (vertexGroups.size() > 0) {
    LOGGER.fine("Gathering vertex groups information to prepare the buffers for the mesh.");
    for (    VertexGroup vertexGroup : vertexGroups.values()) {
      for (      Entry<Integer,Float> entry : vertexGroup.entrySet()) {
        WeightsAndBoneIndexes vertexWeights=weights.get(entry.getKey());
        if (vertexWeights == null) {
          vertexWeights=new WeightsAndBoneIndexes();
          weights.put(entry.getKey(),vertexWeights);
        }
        vertexWeights.put(vertexGroup.getBoneIndex(),entry.getValue());
      }
    }
    LOGGER.log(Level.FINE,"Equalizing the amount of weights per vertex to {0} if any of them has more or less.",MAXIMUM_WEIGHTS_PER_VERTEX);
    for (    Entry<Integer,WeightsAndBoneIndexes> entry : weights.entrySet()) {
      maximumWeightsPerVertex=Math.max(maximumWeightsPerVertex,entry.getValue().size());
      entry.getValue().normalize(MAXIMUM_WEIGHTS_PER_VERTEX);
    }
    if (maximumWeightsPerVertex > MAXIMUM_WEIGHTS_PER_VERTEX) {
      LOGGER.log(Level.WARNING,"{0} has vertices with more than 4 weights assigned. The model may not behave as it should.",meshStructure.getName());
      maximumWeightsPerVertex=MAXIMUM_WEIGHTS_PER_VERTEX;
    }
  }
  if (maximumWeightsPerVertex == 0) {
    LOGGER.fine("No vertex group data nor bone envelopes found to attach vertices to bones!");
    return null;
  }
  LOGGER.fine("Preparing buffers for the mesh.");
  FloatBuffer weightsFloatData=BufferUtils.createFloatBuffer(vertexListSize * MAXIMUM_WEIGHTS_PER_VERTEX);
  ByteBuffer indicesData=BufferUtils.createByteBuffer(vertexListSize * MAXIMUM_WEIGHTS_PER_VERTEX);
  for (int i=0; i < indexes.limit(); ++i) {
    int index=indexes instanceof ShortBuffer ? ((ShortBuffer)indexes).get(i) : ((IntBuffer)indexes).get(i);
    WeightsAndBoneIndexes weightsAndBoneIndexes=weights.get(index);
    if (weightsAndBoneIndexes != null) {
      int count=0;
      for (      Entry<Integer,Float> entry : weightsAndBoneIndexes.entrySet()) {
        weightsFloatData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX + count,entry.getValue());
        indicesData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX + count,entry.getKey().byteValue());
        ++count;
      }
    }
 else {
      weightsFloatData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX,1.0f);
      indicesData.put(index * MAXIMUM_WEIGHTS_PER_VERTEX,(byte)0);
    }
  }
  VertexBuffer verticesWeights=new VertexBuffer(Type.BoneWeight);
  verticesWeights.setupData(Usage.CpuOnly,maximumWeightsPerVertex,Format.Float,weightsFloatData);
  VertexBuffer verticesWeightsIndices=new VertexBuffer(Type.BoneIndex);
  verticesWeightsIndices.setupData(Usage.CpuOnly,maximumWeightsPerVertex,Format.UnsignedByte,indicesData);
  return new MeshWeightsData(maximumWeightsPerVertex,verticesWeights,verticesWeightsIndices);
}
