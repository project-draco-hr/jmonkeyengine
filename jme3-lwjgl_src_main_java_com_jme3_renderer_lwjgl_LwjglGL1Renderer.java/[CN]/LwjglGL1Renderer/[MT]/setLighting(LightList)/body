{
  if (list == null || list.size() == 0) {
    glDisable(GL_LIGHTING);
    applyFixedFuncBindings(false);
    setModelView(worldMatrix,viewMatrix);
    return;
  }
  int numLightsSetPrev=lightList.size();
  lightList.clear();
  materialAmbientColor.set(0,0,0,0);
  for (int i=0; i < list.size(); i++) {
    Light l=list.get(i);
    if (l.getType() == Light.Type.Ambient) {
      materialAmbientColor.addLocal(l.getColor());
    }
 else {
      lightList.add(l);
      if (lightList.size() >= maxLights) {
        break;
      }
    }
  }
  applyFixedFuncBindings(true);
  glEnable(GL_LIGHTING);
  fb16.clear();
  fb16.put(materialAmbientColor.r).put(materialAmbientColor.g).put(materialAmbientColor.b).put(1).flip();
  glLightModel(GL_LIGHT_MODEL_AMBIENT,fb16);
  if (context.matrixMode != GL_MODELVIEW) {
    glMatrixMode(GL_MODELVIEW);
    context.matrixMode=GL_MODELVIEW;
  }
  glLoadMatrix(storeMatrix(viewMatrix,fb16));
  for (int i=0; i < lightList.size(); i++) {
    int glLightIndex=GL_LIGHT0 + i;
    Light light=lightList.get(i);
    Light.Type lightType=light.getType();
    ColorRGBA col=light.getColor();
    Vector3f pos;
    glEnable(glLightIndex);
switch (lightType) {
case Directional:
      DirectionalLight dLight=(DirectionalLight)light;
    fb16.clear();
  fb16.put(col.r).put(col.g).put(col.b).put(col.a).flip();
glLight(glLightIndex,GL_DIFFUSE,fb16);
glLight(glLightIndex,GL_SPECULAR,fb16);
pos=tempVec.set(dLight.getDirection()).negateLocal().normalizeLocal();
fb16.clear();
fb16.put(pos.x).put(pos.y).put(pos.z).put(0.0f).flip();
glLight(glLightIndex,GL_POSITION,fb16);
glLightf(glLightIndex,GL_SPOT_CUTOFF,180);
break;
case Point:
PointLight pLight=(PointLight)light;
fb16.clear();
fb16.put(col.r).put(col.g).put(col.b).put(col.a).flip();
glLight(glLightIndex,GL_DIFFUSE,fb16);
glLight(glLightIndex,GL_SPECULAR,fb16);
pos=pLight.getPosition();
fb16.clear();
fb16.put(pos.x).put(pos.y).put(pos.z).put(1.0f).flip();
glLight(glLightIndex,GL_POSITION,fb16);
glLightf(glLightIndex,GL_SPOT_CUTOFF,180);
if (pLight.getRadius() > 0) {
glLightf(glLightIndex,GL_CONSTANT_ATTENUATION,1);
glLightf(glLightIndex,GL_LINEAR_ATTENUATION,pLight.getInvRadius() * 2);
glLightf(glLightIndex,GL_QUADRATIC_ATTENUATION,pLight.getInvRadius() * pLight.getInvRadius());
}
 else {
glLightf(glLightIndex,GL_CONSTANT_ATTENUATION,1);
glLightf(glLightIndex,GL_LINEAR_ATTENUATION,0);
glLightf(glLightIndex,GL_QUADRATIC_ATTENUATION,0);
}
break;
case Spot:
SpotLight sLight=(SpotLight)light;
fb16.clear();
fb16.put(col.r).put(col.g).put(col.b).put(col.a).flip();
glLight(glLightIndex,GL_DIFFUSE,fb16);
glLight(glLightIndex,GL_SPECULAR,fb16);
pos=sLight.getPosition();
fb16.clear();
fb16.put(pos.x).put(pos.y).put(pos.z).put(1.0f).flip();
glLight(glLightIndex,GL_POSITION,fb16);
Vector3f dir=sLight.getDirection();
fb16.clear();
fb16.put(dir.x).put(dir.y).put(dir.z).put(1.0f).flip();
glLight(glLightIndex,GL_SPOT_DIRECTION,fb16);
float outerAngleRad=sLight.getSpotOuterAngle();
float innerAngleRad=sLight.getSpotInnerAngle();
float spotCut=outerAngleRad * FastMath.RAD_TO_DEG;
float spotExpo=0.0f;
if (outerAngleRad > 0) {
spotExpo=(1.0f - (innerAngleRad / outerAngleRad)) * 128.0f;
}
glLightf(glLightIndex,GL_SPOT_CUTOFF,spotCut);
glLightf(glLightIndex,GL_SPOT_EXPONENT,spotExpo);
if (sLight.getSpotRange() > 0) {
glLightf(glLightIndex,GL_LINEAR_ATTENUATION,sLight.getInvSpotRange());
}
 else {
glLightf(glLightIndex,GL_LINEAR_ATTENUATION,0);
}
break;
default :
throw new UnsupportedOperationException("Unrecognized light type: " + lightType);
}
}
for (int i=lightList.size(); i < numLightsSetPrev; i++) {
glDisable(GL_LIGHT0 + i);
}
setModelView(worldMatrix,viewMatrix);
}
