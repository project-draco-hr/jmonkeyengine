{
  if (packetIndex < 3) {
    if (info.decodeHeader(comment,packet) < 0) {
      System.err.println("does not contain Theora video data.");
      return;
    }
    if (packetIndex == 2) {
      state.decodeInit(info);
      System.out.println("theora frame: " + info.frame_width + "x"+ info.frame_height);
      System.out.println("theora resolution: " + info.width + "x"+ info.height);
      System.out.println("theora aspect: " + info.aspect_numerator + "x"+ info.aspect_denominator);
      System.out.println("theora framerate: " + info.fps_numerator + "x"+ info.fps_denominator);
      xOff=info.offset_x;
      yOff=info.offset_y;
      width=info.frame_width;
      height=info.frame_height;
      initializeFrames();
      if (masterClock instanceof SystemClock) {
        SystemClock clock=(SystemClock)masterClock;
        if (clock.needReset()) {
          clock.reset();
          System.out.println("Note: master clock was reset by video");
        }
      }
    }
  }
 else {
    long granulePos=packet.granulepos;
    long time=(long)(state.granuleTime(granulePos) * Clock.SECONDS_TO_NANOS);
    long oneFrameTime=(long)((Clock.SECONDS_TO_NANOS * info.fps_denominator) / info.fps_numerator);
    if (time >= 0) {
      lastTs=time;
    }
 else {
      lastTs+=oneFrameTime;
      time=lastTs;
    }
    lastUpdateTime=System.nanoTime();
    if (state.decodePacketin(packet) != 0) {
      System.err.println("Error Decoding Theora.");
      return;
    }
    if (state.decodeYUVout(yuv) != 0) {
      System.err.println("Error getting the picture.");
      return;
    }
    decodeRgbFromBuffer(time);
  }
  packetIndex++;
}
