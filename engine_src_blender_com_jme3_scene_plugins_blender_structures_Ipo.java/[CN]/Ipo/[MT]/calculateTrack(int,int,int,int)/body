{
  int framesAmount=stopFrame - startFrame;
  float start=(startFrame - 1.0f) / fps;
  float timeBetweenFrames=1.0f / fps;
  float[] times=new float[framesAmount + 1];
  Vector3f[] translations=new Vector3f[framesAmount + 1];
  float[] translation=new float[3];
  Quaternion[] rotations=new Quaternion[framesAmount + 1];
  float[] quaternionRotation=new float[4];
  float[] objectRotation=new float[3];
  boolean bObjectRotation=false;
  Vector3f[] scales=new Vector3f[framesAmount + 1];
  float[] scale=new float[3];
  for (int frame=startFrame; frame <= stopFrame; ++frame) {
    int index=frame - startFrame;
    times[index]=start + (frame - 1) * timeBetweenFrames;
    for (int j=0; j < bezierCurves.length; ++j) {
      double value=bezierCurves[j].evaluate(frame,BezierCurve.Y_VALUE);
switch (bezierCurves[j].getType()) {
case AC_LOC_X:
case AC_LOC_Y:
case AC_LOC_Z:
        translation[bezierCurves[j].getType() - 1]=(float)value;
      break;
case OB_ROT_X:
case OB_ROT_Y:
case OB_ROT_Z:
    objectRotation[bezierCurves[j].getType() - 7]=(float)value;
  bObjectRotation=true;
break;
case AC_SIZE_X:
case AC_SIZE_Y:
case AC_SIZE_Z:
scale[bezierCurves[j].getType() - 13]=(float)value;
break;
case AC_QUAT_W:
quaternionRotation[3]=(float)value;
break;
case AC_QUAT_X:
case AC_QUAT_Y:
case AC_QUAT_Z:
quaternionRotation[bezierCurves[j].getType() - 26]=(float)value;
break;
default :
}
}
translations[index]=new Vector3f(translation[0],translation[1],translation[2]);
rotations[index]=bObjectRotation ? new Quaternion().fromAngles(objectRotation) : new Quaternion(quaternionRotation[0],quaternionRotation[1],quaternionRotation[2],quaternionRotation[3]);
scales[index]=new Vector3f(scale[0],scale[1],scale[2]);
}
calculatedTrack=new BoneTrack(boneIndex,times,translations,rotations,scales);
return calculatedTrack;
}
