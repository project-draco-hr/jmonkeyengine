{
  Collections.sort(tris,comparator);
  HashMap<Integer,Range> ranges=new HashMap<Integer,Range>();
  for (int i=0; i < tris.size(); i++) {
    Range r=ranges.get(tris.get(i).getGeometryIndex());
    if (r != null) {
      r.setLength(r.getLength() + 1);
    }
 else {
      ranges.put(tris.get(i).getGeometryIndex(),new Range(i,1));
    }
  }
  List<Geometry> newGeoms=new ArrayList<Geometry>();
  int[] vertIndicies=new int[3];
  int[] newIndices=new int[3];
  boolean[] vertexCreated=new boolean[3];
  HashMap<Integer,Integer> indexCache=new HashMap<Integer,Integer>();
  for (  Map.Entry<Integer,Range> entry : ranges.entrySet()) {
    int inGeomIndex=entry.getKey().intValue();
    int outOffset=entry.getValue().start;
    int outLength=entry.getValue().length;
    Geometry inGeom=inGeoms[inGeomIndex];
    Mesh in=inGeom.getMesh();
    Mesh out=new Mesh();
    int outElementCount=outLength * 3;
    ShortBuffer ib=BufferUtils.createShortBuffer(outElementCount);
    out.setBuffer(Type.Index,3,ib);
    IntMap<VertexBuffer> bufs=in.getBuffers();
    for (    Entry<VertexBuffer> ent : bufs) {
      VertexBuffer vb=ent.getValue();
      if (vb.getBufferType() == Type.Index)       continue;
      Buffer b=VertexBuffer.createBuffer(vb.getFormat(),vb.getNumComponents(),outElementCount);
      VertexBuffer outVb=new VertexBuffer(vb.getBufferType());
      outVb.setNormalized(vb.isNormalized());
      outVb.setupData(vb.getUsage(),vb.getNumComponents(),vb.getFormat(),b);
      out.setBuffer(outVb);
    }
    int currentVertex=0;
    for (int i=outOffset; i < outOffset + outLength; i++) {
      OCTTriangle t=tris.get(i);
      in.getTriangle(t.getTriangleIndex(),vertIndicies);
      Integer i0=indexCache.get(vertIndicies[0]);
      Integer i1=indexCache.get(vertIndicies[1]);
      Integer i2=indexCache.get(vertIndicies[2]);
      if (i0 == null) {
        vertexCreated[0]=true;
        newIndices[0]=currentVertex++;
        indexCache.put(vertIndicies[0],newIndices[0]);
      }
 else {
        newIndices[0]=i0.intValue();
        vertexCreated[0]=false;
      }
      if (i1 == null) {
        vertexCreated[1]=true;
        newIndices[1]=currentVertex++;
        indexCache.put(vertIndicies[1],newIndices[1]);
      }
 else {
        newIndices[1]=i1.intValue();
        vertexCreated[1]=false;
      }
      if (i2 == null) {
        vertexCreated[2]=true;
        newIndices[2]=currentVertex++;
        indexCache.put(vertIndicies[2],newIndices[2]);
      }
 else {
        newIndices[2]=i2.intValue();
        vertexCreated[2]=false;
      }
      IntMap<VertexBuffer> inbufs=in.getBuffers();
      for (      Entry<VertexBuffer> ent : inbufs) {
        VertexBuffer vb=ent.getValue();
        if (vb.getBufferType() == Type.Index)         continue;
        VertexBuffer outVb=out.getBuffer(vb.getBufferType());
        for (int v=0; v < 3; v++) {
          if (!vertexCreated[v])           continue;
          vb.copyElement(vertIndicies[v],outVb,newIndices[v]);
        }
      }
      ib.put((short)newIndices[0]).put((short)newIndices[1]).put((short)newIndices[2]);
    }
    ib.clear();
    indexCache.clear();
    IntMap<VertexBuffer> outbufs=out.getBuffers();
    for (    Entry<VertexBuffer> ent : outbufs) {
      VertexBuffer vb=ent.getValue();
      if (vb.getBufferType() == Type.Index)       continue;
      vb.compact(currentVertex);
    }
    out.updateBound();
    out.updateCounts();
    out.setStatic();
    Geometry outGeom=new Geometry("Geom" + entry.getKey(),out);
    outGeom.setLocalTransform(inGeom.getWorldTransform());
    outGeom.setMaterial(inGeom.getMaterial());
    for (    Light light : inGeom.getWorldLightList()) {
      outGeom.addLight(light);
    }
    outGeom.updateGeometricState();
    newGeoms.add(outGeom);
  }
  return newGeoms;
}
