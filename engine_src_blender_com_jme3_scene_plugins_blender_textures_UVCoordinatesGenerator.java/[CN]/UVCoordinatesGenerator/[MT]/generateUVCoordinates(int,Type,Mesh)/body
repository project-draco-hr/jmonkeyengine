{
  VertexBuffer result=null;
switch (texco) {
case TEXCO_ORCO:
    if (textureType == Type.TwoDimensional) {
    }
 else     if (textureType == Type.ThreeDimensional) {
      BoundingBox bb=UVCoordinatesGenerator.getBoundingBox(mesh);
      result=new VertexBuffer(com.jme3.scene.VertexBuffer.Type.TexCoord);
      FloatBuffer positions=mesh.getFloatBuffer(com.jme3.scene.VertexBuffer.Type.Position);
      float[] uvCoordinates=BufferUtils.getFloatArray(positions);
      Vector3f min=bb.getMin(null);
      float[] ext=new float[]{bb.getXExtent() * 2,bb.getYExtent() * 2,bb.getZExtent() * 2};
      for (int i=0; i < uvCoordinates.length; i+=3) {
        uvCoordinates[i]=(uvCoordinates[i] - min.x) / ext[0];
        uvCoordinates[i + 1]=(uvCoordinates[i + 1] - min.y) / ext[1];
        uvCoordinates[i + 2]=(uvCoordinates[i + 2] - min.z) / ext[2];
      }
      result.setupData(Usage.Static,3,Format.Float,BufferUtils.createFloatBuffer(uvCoordinates));
    }
 else {
      throw new IllegalStateException("Unsupported texture type: " + textureType);
    }
  break;
case TEXCO_GLOB:
break;
case TEXCO_TANGENT:
break;
case TEXCO_UV:
break;
case TEXCO_STRESS:
break;
case TEXCO_NORM:
break;
case TEXCO_LAVECTOR:
case TEXCO_OBJECT:
case TEXCO_OSA:
case TEXCO_PARTICLE_OR_STRAND:
case TEXCO_REFL:
case TEXCO_SPEED:
case TEXCO_STICKY:
case TEXCO_VIEW:
case TEXCO_WINDOW:
LOGGER.warning("Texture coordinates type not currently supported: " + texco);
break;
default :
throw new IllegalStateException("Unknown texture coordinates value: " + texco);
}
mesh.clearBuffer(VertexBuffer.Type.TexCoord);
mesh.setBuffer(result);
}
