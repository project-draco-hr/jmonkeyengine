{
  if (textureDimension != 2 && textureDimension != 3) {
    throw new IllegalStateException("Unsupported texture dimension: " + textureDimension);
  }
  VertexBuffer result=new VertexBuffer(VertexBuffer.Type.TexCoord);
  Mesh mesh=geometries.get(0).getMesh();
  BoundingBox bb=UVCoordinatesGenerator.getBoundingBox(geometries);
  float[] inputData=null;
switch (texco) {
case TEXCO_ORCO:
    inputData=BufferUtils.getFloatArray(mesh.getFloatBuffer(VertexBuffer.Type.Position));
  break;
case TEXCO_UV:
FloatBuffer uvCoordinatesBuffer=BufferUtils.createFloatBuffer(mesh.getVertexCount() * textureDimension);
Vector2f[] data=new Vector2f[]{new Vector2f(0,1),new Vector2f(0,0),new Vector2f(1,0)};
for (int i=0; i < mesh.getVertexCount(); ++i) {
Vector2f uv=data[i % 3];
uvCoordinatesBuffer.put(uv.x);
uvCoordinatesBuffer.put(uv.y);
if (textureDimension == 3) {
uvCoordinatesBuffer.put(0);
}
}
result.setupData(Usage.Static,textureDimension,Format.Float,uvCoordinatesBuffer);
break;
case TEXCO_NORM:
inputData=BufferUtils.getFloatArray(mesh.getFloatBuffer(VertexBuffer.Type.Normal));
break;
case TEXCO_REFL:
case TEXCO_GLOB:
case TEXCO_TANGENT:
case TEXCO_STRESS:
case TEXCO_LAVECTOR:
case TEXCO_OBJECT:
case TEXCO_OSA:
case TEXCO_PARTICLE_OR_STRAND:
case TEXCO_SPEED:
case TEXCO_STICKY:
case TEXCO_VIEW:
case TEXCO_WINDOW:
LOGGER.warning("Texture coordinates type not currently supported: " + texco);
break;
default :
throw new IllegalStateException("Unknown texture coordinates value: " + texco);
}
if (inputData != null) {
if (textureDimension == 2) {
switch (projection) {
case PROJECTION_FLAT:
inputData=UVProjectionGenerator.flatProjection(mesh,bb);
break;
case PROJECTION_CUBE:
inputData=UVProjectionGenerator.cubeProjection(mesh,bb);
break;
case PROJECTION_TUBE:
BoundingTube bt=UVCoordinatesGenerator.getBoundingTube(geometries);
inputData=UVProjectionGenerator.tubeProjection(mesh,bt);
break;
case PROJECTION_SPHERE:
BoundingSphere bs=UVCoordinatesGenerator.getBoundingSphere(geometries);
inputData=UVProjectionGenerator.sphereProjection(mesh,bs);
break;
default :
throw new IllegalStateException("Unknown projection type: " + projection);
}
}
 else {
Vector3f min=bb.getMin(null);
float[] uvCoordsResults=new float[4];
float[] ext=new float[]{bb.getXExtent() * 2,bb.getYExtent() * 2,bb.getZExtent() * 2};
for (int i=0; i < inputData.length; i+=3) {
uvCoordsResults[1]=(inputData[i] - min.x) / ext[0];
uvCoordsResults[2]=(inputData[i + 1] - min.y) / ext[1];
uvCoordsResults[3]=(inputData[i + 2] - min.z) / ext[2];
inputData[i]=uvCoordsResults[coordinatesSwappingIndexes[0]];
inputData[i + 1]=uvCoordsResults[coordinatesSwappingIndexes[1]];
inputData[i + 2]=uvCoordsResults[coordinatesSwappingIndexes[2]];
}
}
result.setupData(Usage.Static,textureDimension,Format.Float,BufferUtils.createFloatBuffer(inputData));
}
for (Geometry geometry : geometries) {
mesh=geometry.getMesh();
mesh.clearBuffer(VertexBuffer.Type.TexCoord);
mesh.setBuffer(result);
}
return result;
}
