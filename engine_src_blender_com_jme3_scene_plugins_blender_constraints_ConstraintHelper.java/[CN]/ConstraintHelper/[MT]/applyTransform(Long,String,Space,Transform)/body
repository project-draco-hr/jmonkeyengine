{
  Spatial feature=(Spatial)blenderContext.getLoadedFeature(oma,LoadedFeatureDataType.LOADED_FEATURE);
  boolean isArmature=blenderContext.getMarkerValue(ArmatureHelper.ARMATURE_NODE_MARKER,feature) != null;
  if (isArmature) {
    Skeleton skeleton=blenderContext.getSkeleton(oma);
    BoneContext targetBoneContext=blenderContext.getBoneByName(subtargetName);
    Bone bone=targetBoneContext.getBone();
    Node nodeControlledBySkeleton=blenderContext.getControlledNode(skeleton);
    Transform nodeTransform=nodeControlledBySkeleton.getWorldTransform();
    Matrix4f invertedNodeMatrix=this.toMatrix(nodeTransform).invertLocal();
switch (space) {
case CONSTRAINT_SPACE_LOCAL:
      bone.setBindTransforms(transform.getTranslation(),transform.getRotation(),transform.getScale());
    break;
case CONSTRAINT_SPACE_WORLD:
  Matrix4f boneMatrixInWorldSpace=this.toMatrix(transform);
Matrix4f invertedModelMatrix=this.toMatrix(this.getTransform(targetBoneContext.getSkeletonOwnerOma(),null,Space.CONSTRAINT_SPACE_WORLD)).invertLocal();
Matrix4f boneMatrixInModelSpace=invertedModelMatrix.mult(boneMatrixInWorldSpace);
Bone parent=bone.getParent();
if (parent != null) {
Matrix4f invertedParentMatrixInModelSpace=this.toMatrix(parent.getModelSpacePosition(),parent.getModelSpaceRotation(),parent.getModelSpaceScale()).invertLocal();
boneMatrixInModelSpace=invertedParentMatrixInModelSpace.mult(boneMatrixInModelSpace);
}
bone.setBindTransforms(boneMatrixInModelSpace.toTranslationVector(),boneMatrixInModelSpace.toRotationQuat(),boneMatrixInModelSpace.toScaleVector());
break;
case CONSTRAINT_SPACE_POSE:
Matrix4f armatureWorldMatrix=this.toMatrix(feature.getWorldTransform());
Matrix4f bonePoseMatrix=this.toMatrix(transform);
Matrix4f boneWorldMatrix=armatureWorldMatrix.multLocal(bonePoseMatrix);
Matrix4f boneLocalMatrix=invertedNodeMatrix.multLocal(boneWorldMatrix);
Vector3f loc2=boneLocalMatrix.toTranslationVector();
Quaternion rot2=boneLocalMatrix.toRotationQuat().normalizeLocal().multLocal(new Quaternion(NEG_POSE_SPACE_QUATERNION));
Vector3f scl2=boneLocalMatrix.toScaleVector();
bone.setBindTransforms(loc2,rot2,scl2);
break;
case CONSTRAINT_SPACE_PARLOCAL:
Matrix4f parentLocalMatrix=Matrix4f.IDENTITY;
if (bone.getParent() != null) {
parentLocalMatrix=this.toMatrix(bone.getParent().getLocalPosition(),bone.getParent().getLocalRotation(),bone.getParent().getLocalScale());
parentLocalMatrix.invertLocal();
}
 else {
parentLocalMatrix=parentLocalMatrix.clone();
}
Matrix4f m=this.toMatrix(transform.getTranslation(),transform.getRotation(),transform.getScale());
Matrix4f result=parentLocalMatrix.multLocal(m);
Vector3f loc=result.toTranslationVector();
Quaternion rot=result.toRotationQuat().normalizeLocal().multLocal(POS_PARLOC_SPACE_QUATERNION);
Vector3f scl=result.toScaleVector();
bone.setBindTransforms(loc,rot,scl);
break;
default :
throw new IllegalStateException("Invalid space type for target object: " + space.toString());
}
}
 else {
switch (space) {
case CONSTRAINT_SPACE_LOCAL:
feature.getLocalTransform().set(transform);
break;
case CONSTRAINT_SPACE_WORLD:
if (feature.getParent() == null) {
feature.setLocalTransform(transform);
}
 else {
Transform parentWorldTransform=feature.getParent().getWorldTransform();
Matrix4f parentMatrix=this.toMatrix(parentWorldTransform).invertLocal();
Matrix4f m=this.toMatrix(transform);
m=m.multLocal(parentMatrix);
transform.setTranslation(m.toTranslationVector());
transform.setRotation(m.toRotationQuat());
transform.setScale(m.toScaleVector());
feature.setLocalTransform(transform);
}
break;
default :
throw new IllegalStateException("Invalid space type for spatial object: " + space.toString());
}
}
}
