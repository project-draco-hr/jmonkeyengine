{
  if (resultUVS.size() != basicUVSOwner.resultUVS.size()) {
    throw new IllegalStateException("The amount of UV coordinates must be equal in order to cast one UV's onto another!");
  }
  if (!resultUVS.equals(basicUVSOwner.resultUVS)) {
    if (!basicUVSOwner.wasTriangulated) {
      throw new IllegalStateException("The given texture must be triangulated!");
    }
    if (!this.wasTriangulated) {
      resultTexture=new TriangulatedTexture((Texture2D)resultTexture,resultUVS,blenderContext);
      resultUVS=((TriangulatedTexture)resultTexture).getResultUVS();
      resultTexture=((TriangulatedTexture)resultTexture).getResultTexture();
    }
    TextureHelper textureHelper=blenderContext.getHelper(TextureHelper.class);
    ImageLoader imageLoader=new ImageLoader();
    List<TriangleTextureElement> faceTextures=new ArrayList<TriangleTextureElement>();
    List<Vector2f> basicUVS=basicUVSOwner.getResultUVS();
    int[] imageRectangle=new int[4];
    int[] sourceSize=new int[2], targetSize=new int[2];
    Vector2f[] destinationUVS=new Vector2f[3];
    Vector2f[] sourceUVS=new Vector2f[3];
    List<Vector2f> partImageUVS=Arrays.asList(new Vector2f(),new Vector2f(),new Vector2f());
    int faceIndex=0;
    for (int i=0; i < basicUVS.size(); i+=3) {
      destinationUVS[0]=basicUVS.get(i);
      destinationUVS[1]=basicUVS.get(i + 1);
      destinationUVS[2]=basicUVS.get(i + 2);
      this.computeImageRectangle(destinationUVS,imageRectangle,basicUVSOwner.resultTexture.getImage().getWidth(),basicUVSOwner.resultTexture.getImage().getHeight(),blenderContext);
      targetSize[0]=imageRectangle[2] - imageRectangle[0];
      targetSize[1]=imageRectangle[3] - imageRectangle[1];
      for (int j=0; j < 3; ++j) {
        partImageUVS.get(j).set((basicUVSOwner.resultTexture.getImage().getWidth() * destinationUVS[j].x - imageRectangle[0]) / targetSize[0],(basicUVSOwner.resultTexture.getImage().getHeight() * destinationUVS[j].y - imageRectangle[1]) / targetSize[1]);
      }
      sourceUVS[0]=resultUVS.get(i);
      sourceUVS[1]=resultUVS.get(i + 1);
      sourceUVS[2]=resultUVS.get(i + 2);
      this.computeImageRectangle(sourceUVS,imageRectangle,resultTexture.getImage().getWidth(),resultTexture.getImage().getHeight(),blenderContext);
      sourceSize[0]=imageRectangle[2] - imageRectangle[0];
      sourceSize[1]=imageRectangle[3] - imageRectangle[1];
      float xTranslateFactor=imageRectangle[0] / (float)resultTexture.getImage().getWidth();
      float xStreachFactor=resultTexture.getImage().getWidth() / (float)sourceSize[0];
      float yTranslateFactor=imageRectangle[1] / (float)resultTexture.getImage().getHeight();
      float yStreachFactor=resultTexture.getImage().getHeight() / (float)sourceSize[1];
      for (int j=0; j < 3; ++j) {
        sourceUVS[j].x=(sourceUVS[j].x - xTranslateFactor) * xStreachFactor;
        sourceUVS[j].y=(sourceUVS[j].y - yTranslateFactor) * yStreachFactor;
      }
      AffineTransform affineTransform=textureHelper.createAffineTransform(sourceUVS,partImageUVS.toArray(new Vector2f[3]),sourceSize,targetSize);
      Image image=textureHelper.getSubimage(resultTexture.getImage(),imageRectangle[0],imageRectangle[1],imageRectangle[2],imageRectangle[3]);
      BufferedImage sourceImage=ImageToAwt.convert(image,false,true,0);
      BufferedImage targetImage=new BufferedImage(targetSize[0],targetSize[1],sourceImage.getType());
      Graphics2D g=targetImage.createGraphics();
      g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
      g.drawImage(sourceImage,affineTransform,null);
      g.dispose();
      Image output=imageLoader.load(targetImage,false);
      faceTextures.add(new TriangleTextureElement(faceIndex++,output,partImageUVS,false,blenderContext));
    }
    TriangulatedTexture triangulatedTexture=new TriangulatedTexture(faceTextures,blenderContext);
    triangulatedTexture.setKeepIdenticalTextures(false);
    resultTexture=triangulatedTexture.getResultTexture();
    resultUVS=basicUVS;
  }
}
