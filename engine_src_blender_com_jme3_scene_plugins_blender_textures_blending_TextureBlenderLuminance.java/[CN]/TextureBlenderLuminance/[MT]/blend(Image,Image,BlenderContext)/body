{
  Format format=image.getFormat();
  ByteBuffer data=image.getData(0);
  data.rewind();
  PixelInputOutput basePixelIO=null;
  TexturePixel basePixel=null;
  float[] materialColor=this.materialColor;
  if (baseImage != null) {
    basePixelIO=PixelIOFactory.getPixelIO(baseImage.getFormat());
    materialColor=new float[this.materialColor.length];
    basePixel=new TexturePixel();
  }
  int width=image.getWidth();
  int height=image.getHeight();
  int depth=image.getDepth();
  if (depth == 0) {
    depth=1;
  }
  ByteBuffer newData=BufferUtils.createByteBuffer(width * height * depth* 4);
  float[] resultPixel=new float[4];
  float[] tinAndAlpha=new float[2];
  int dataIndex=0, x=0, y=0;
  while (data.hasRemaining()) {
    if (basePixelIO != null) {
      basePixelIO.read(baseImage,basePixel,x,y);
      basePixel.toRGBA(materialColor);
    }
    this.getTinAndAlpha(data,format,negateTexture,tinAndAlpha);
    this.blendPixel(resultPixel,materialColor,color,tinAndAlpha[0],blendFactor,blendType,blenderContext);
    newData.put(dataIndex++,(byte)(resultPixel[0] * 255.0f));
    newData.put(dataIndex++,(byte)(resultPixel[1] * 255.0f));
    newData.put(dataIndex++,(byte)(resultPixel[2] * 255.0f));
    newData.put(dataIndex++,(byte)(tinAndAlpha[1] * 255.0f));
    ++x;
    if (x >= width) {
      x=0;
      ++y;
    }
  }
  if (depth > 1) {
    ArrayList<ByteBuffer> dataArray=new ArrayList<ByteBuffer>(1);
    dataArray.add(newData);
    return new Image(Format.RGBA8,width,height,depth,dataArray);
  }
 else {
    return new Image(Format.RGBA8,width,height,newData);
  }
}
