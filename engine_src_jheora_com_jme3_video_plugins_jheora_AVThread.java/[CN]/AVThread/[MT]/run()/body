{
  page=new Page();
  packet=new Packet();
  syncState=new SyncState();
  while (!cancel.get()) {
    int index=syncState.buffer(BUFFSIZE);
    int read;
    try {
      read=oggStream.read(syncState.data,index,BUFFSIZE);
    }
 catch (    IOException ex) {
      logger.log(Level.SEVERE,"Error while decoding Ogg Video",ex);
      return;
    }
    if (read < 0) {
      break;
    }
    syncState.wrote(read);
    while (!cancel.get()) {
      int res=syncState.pageout(page);
      if (res == 0)       break;
      if (res == -1) {
      }
 else {
        int serial=page.serialno();
        StreamState state=streams.get(serial);
        boolean newStream=false;
        if (state == null) {
          state=new StreamState();
          state.init(serial);
          state.reset();
          streams.put(serial,state);
          newStream=true;
        }
        res=state.pagein(page);
        if (res < 0) {
          System.err.println("Error reading first page of Ogg bitstream data.");
          return;
        }
        while (!cancel.get()) {
          res=state.packetout(packet);
          if (res == 0)           break;
          if (res == -1) {
          }
 else {
            if (newStream) {
              int packetId=packet.packet;
              byte[] packetBase=packet.packet_base;
              if (packetBase[packetId + 1] == 0x76) {
                vorbisSerial=serial;
              }
 else               if (packet.packet_base[packet.packet + 1] == 0x73) {
                logger.log(Level.WARNING,"Smoke video detected. Unsupported!");
              }
 else               if (packet.packet_base[packet.packet + 1] == 0x74) {
                theoraSerial=serial;
              }
            }
            if (serial == theoraSerial) {
              videoDecoder.decode(packet);
            }
 else             if (serial == vorbisSerial) {
              audioDecoder.decode(packet);
            }
          }
        }
      }
    }
  }
  done();
}
