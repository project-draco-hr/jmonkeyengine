{
  while (true) {
    SSLEngineResult result;
    log.log(Level.FINEST,"[{0}][TCP] Handshake Status is now {1}.",new Object[]{label,handshakeStatus});
switch (handshakeStatus) {
case NOT_HANDSHAKING:
      log.log(Level.SEVERE,"[{0}][TCP] We're doing a handshake while we're not handshaking.",label);
    break;
case FINISHED:
  initialHandshake=false;
channel.keyFor(selector).interestOps(SelectionKey.OP_READ);
return;
case NEED_TASK:
Runnable task;
while ((task=sslEngine.getDelegatedTask()) != null) {
task.run();
}
handshakeStatus=sslEngine.getHandshakeStatus();
break;
case NEED_UNWRAP:
readAndUnwrap(channel);
if (initialHandshake && status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
channel.keyFor(selector).interestOps(SelectionKey.OP_READ);
return;
}
break;
case NEED_WRAP:
if (outDataEncrypted.hasRemaining()) {
log.log(Level.FINE,"[{0}][TCP] We found data that should be written out.",label);
return;
}
outDataEncrypted.clear();
result=sslEngine.wrap(dummy,outDataEncrypted);
log.log(Level.FINEST,"[{0}][TCP] Wrapping result: {1}.",new Object[]{label,result});
if (result.bytesProduced() == 0) log.log(Level.SEVERE,"[{0}][TCP] No net data produced during wrap.",label);
if (result.bytesConsumed() != 0) log.log(Level.SEVERE,"[{0}][TCP] App data consumed during handshake wrap.",label);
handshakeStatus=result.getHandshakeStatus();
outDataEncrypted.flip();
System.out.println("WRITING TO: " + channel + " : "+ channel.socket());
if (!flushData(channel)) {
return;
}
break;
}
}
}
