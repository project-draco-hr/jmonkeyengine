{
  int threshold=cacheSize;
  StripInfoVec tempStrips=new StripInfoVec();
  int j;
  for (int i=0; i < allStrips.size(); i++) {
    StripInfo currentStrip;
    StripStartInfo startInfo=new StripStartInfo(null,null,false);
    int actualStripSize=0;
    for (j=0; j < allStrips.at(i).m_faces.size(); ++j) {
      if (!isDegenerate(allStrips.at(i).m_faces.at(j)))       actualStripSize++;
    }
    if (actualStripSize > threshold) {
      int numTimes=actualStripSize / threshold;
      int numLeftover=actualStripSize % threshold;
      int degenerateCount=0;
      for (j=0; j < numTimes; j++) {
        currentStrip=new StripInfo(startInfo,0,-1);
        int faceCtr=j * threshold + degenerateCount;
        boolean bFirstTime=true;
        while (faceCtr < threshold + (j * threshold) + degenerateCount) {
          if (isDegenerate(allStrips.at(i).m_faces.at(faceCtr))) {
            degenerateCount++;
            if ((((faceCtr + 1) != threshold + (j * threshold) + degenerateCount) || ((j == numTimes - 1) && (numLeftover < 4) && (numLeftover > 0))) && !bFirstTime) {
              currentStrip.m_faces.add(allStrips.at(i).m_faces.at(faceCtr++));
            }
 else             ++faceCtr;
          }
 else {
            currentStrip.m_faces.add(allStrips.at(i).m_faces.at(faceCtr++));
            bFirstTime=false;
          }
        }
        if (j == numTimes - 1) {
          if ((numLeftover < 4) && (numLeftover > 0)) {
            int ctr=0;
            while (ctr < numLeftover) {
              if (!isDegenerate(allStrips.at(i).m_faces.at(faceCtr))) {
                currentStrip.m_faces.add(allStrips.at(i).m_faces.at(faceCtr++));
                ++ctr;
              }
 else {
                currentStrip.m_faces.add(allStrips.at(i).m_faces.at(faceCtr++));
                ++degenerateCount;
              }
            }
            numLeftover=0;
          }
        }
        tempStrips.add(currentStrip);
      }
      int leftOff=j * threshold + degenerateCount;
      if (numLeftover != 0) {
        currentStrip=new StripInfo(startInfo,0,-1);
        int ctr=0;
        boolean bFirstTime=true;
        while (ctr < numLeftover) {
          if (!isDegenerate(allStrips.at(i).m_faces.at(leftOff))) {
            ctr++;
            bFirstTime=false;
            currentStrip.m_faces.add(allStrips.at(i).m_faces.at(leftOff++));
          }
 else           if (!bFirstTime)           currentStrip.m_faces.add(allStrips.at(i).m_faces.at(leftOff++));
 else           leftOff++;
        }
        tempStrips.add(currentStrip);
      }
    }
 else {
      currentStrip=new StripInfo(startInfo,0,-1);
      for (j=0; j < allStrips.at(i).m_faces.size(); j++)       currentStrip.m_faces.add(allStrips.at(i).m_faces.at(j));
      tempStrips.add(currentStrip);
    }
  }
  StripInfoVec tempStrips2=new StripInfoVec();
  removeSmallStrips(tempStrips,tempStrips2,outFaceList);
  outStrips.clear();
  if (tempStrips2.size() != 0) {
    VertexCache vcache=new VertexCache(cacheSize);
    float bestNumHits=-1.0f;
    float numHits;
    int bestIndex=-99999;
    int firstIndex=0;
    float minCost=10000.0f;
    for (int i=0; i < tempStrips2.size(); i++) {
      int numNeighbors=0;
      for (j=0; j < tempStrips2.at(i).m_faces.size(); j++) {
        numNeighbors+=numNeighbors(tempStrips2.at(i).m_faces.at(j),edgeInfos);
      }
      float currCost=(float)numNeighbors / (float)tempStrips2.at(i).m_faces.size();
      if (currCost < minCost) {
        minCost=currCost;
        firstIndex=i;
      }
    }
    updateCacheStrip(vcache,tempStrips2.at(firstIndex));
    outStrips.add(tempStrips2.at(firstIndex));
    tempStrips2.at(firstIndex).visited=true;
    boolean bWantsCW=(tempStrips2.at(firstIndex).m_faces.size() % 2) == 0;
    while (true) {
      bestNumHits=-1.0f;
      for (int i=0; i < tempStrips2.size(); i++) {
        if (tempStrips2.at(i).visited)         continue;
        numHits=calcNumHitsStrip(vcache,tempStrips2.at(i));
        if (numHits > bestNumHits) {
          bestNumHits=numHits;
          bestIndex=i;
        }
 else         if (numHits >= bestNumHits) {
          StripInfo strip=tempStrips2.at(i);
          int nStripFaceCount=strip.m_faces.size();
          FaceInfo tFirstFace=new FaceInfo(strip.m_faces.at(0).m_v0,strip.m_faces.at(0).m_v1,strip.m_faces.at(0).m_v2);
          if (nStripFaceCount > 1) {
            int nUnique=getUniqueVertexInB(strip.m_faces.at(1),tFirstFace);
            if (nUnique == tFirstFace.m_v1) {
              int tmp=tFirstFace.m_v0;
              tFirstFace.m_v0=tFirstFace.m_v1;
              tFirstFace.m_v1=tmp;
            }
 else             if (nUnique == tFirstFace.m_v2) {
              int tmp=tFirstFace.m_v0;
              tFirstFace.m_v0=tFirstFace.m_v2;
              tFirstFace.m_v2=tmp;
            }
            if (nStripFaceCount > 2) {
              int[] nShared=new int[2];
              getSharedVertices(strip.m_faces.at(2),tFirstFace,nShared);
              if ((nShared[0] == tFirstFace.m_v1) && (nShared[1] == -1)) {
                int tmp=tFirstFace.m_v2;
                tFirstFace.m_v2=tFirstFace.m_v1;
                tFirstFace.m_v1=tmp;
              }
            }
          }
          if (bWantsCW == isCW(strip.m_faces.at(0),tFirstFace.m_v0,tFirstFace.m_v1)) {
            bestIndex=i;
          }
        }
      }
      if (bestNumHits == -1.0f)       break;
      tempStrips2.at(bestIndex).visited=true;
      updateCacheStrip(vcache,tempStrips2.at(bestIndex));
      outStrips.add(tempStrips2.at(bestIndex));
      bWantsCW=(tempStrips2.at(bestIndex).m_faces.size() % 2 == 0) ? bWantsCW : !bWantsCW;
    }
  }
}
