{
  if (indexBuf.getBufferType() != VertexBuffer.Type.Index) {
    throw new IllegalArgumentException("Only index buffers are allowed as triangle lists.");
  }
  boolean useInstancing=count > 1 && caps.contains(Caps.MeshInstancing);
  if (useInstancing) {
    throw new IllegalArgumentException("Caps.MeshInstancing is not supported.");
  }
  int vertCount=mesh.getVertexCount();
  Buffer indexData=indexBuf.getData();
  indexData.rewind();
  if (mesh.getMode() == Mode.Hybrid) {
    int[] modeStart=mesh.getModeStart();
    int[] elementLengths=mesh.getElementLengths();
    int elMode=convertElementMode(Mode.Triangles);
    int fmt=convertVertexBufferFormat(indexBuf.getFormat());
    int elSize=indexBuf.getFormat().getComponentSize();
    int listStart=modeStart[0];
    int stripStart=modeStart[1];
    int fanStart=modeStart[2];
    int curOffset=0;
    for (int i=0; i < elementLengths.length; i++) {
      if (i == stripStart) {
        elMode=convertElementMode(Mode.TriangleStrip);
      }
 else       if (i == fanStart) {
        elMode=convertElementMode(Mode.TriangleFan);
      }
      int elementLength=elementLengths[i];
      indexBuf.getData().position(curOffset);
      GLES20.glDrawElements(elMode,elementLength,fmt,indexBuf.getData());
      RendererUtil.checkGLError();
      curOffset+=elementLength * elSize;
    }
  }
 else {
    GLES20.glDrawElements(convertElementMode(mesh.getMode()),indexBuf.getData().limit(),convertVertexBufferFormat(indexBuf.getFormat()),indexBuf.getData());
    RendererUtil.checkGLError();
  }
}
