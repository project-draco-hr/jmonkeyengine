{
  if (verboseLogging) {
    logger.info("drawTriangleList_Array(Count = " + count + ")");
  }
  if (indexBuf.getBufferType() != VertexBuffer.Type.Index) {
    throw new IllegalArgumentException("Only index buffers are allowed as triangle lists.");
  }
  boolean useInstancing=count > 1 && caps.contains(Caps.MeshInstancing);
  if (useInstancing) {
    throw new IllegalArgumentException("Caps.MeshInstancing is not supported.");
  }
  int vertCount=mesh.getVertexCount();
  Buffer indexData=indexBuf.getData();
  indexData.clear();
  if (mesh.getMode() == Mode.Hybrid) {
    int[] modeStart=mesh.getModeStart();
    int[] elementLengths=mesh.getElementLengths();
    int elMode=convertElementMode(Mode.Triangles);
    int fmt=convertFormat(indexBuf.getFormat());
    int elSize=indexBuf.getFormat().getComponentSize();
    int listStart=modeStart[0];
    int stripStart=modeStart[1];
    int fanStart=modeStart[2];
    int curOffset=0;
    for (int i=0; i < elementLengths.length; i++) {
      if (i == stripStart) {
        elMode=convertElementMode(Mode.TriangleStrip);
      }
 else       if (i == fanStart) {
        elMode=convertElementMode(Mode.TriangleStrip);
      }
      int elementLength=elementLengths[i];
      indexBuf.getData().position(curOffset);
      if (verboseLogging) {
        logger.info("glDrawElements(): " + elementLength + ", "+ curOffset);
      }
      GLES20.glDrawElements(elMode,elementLength,fmt,indexBuf.getData());
      curOffset+=elementLength * elSize;
    }
  }
 else {
    if (verboseLogging) {
      logger.info("glDrawElements(), indexBuf.capacity (" + indexBuf.getData().capacity() + "), vertCount ("+ vertCount+ ")");
    }
    GLES20.glDrawElements(convertElementMode(mesh.getMode()),indexBuf.getData().capacity(),convertFormat(indexBuf.getFormat()),indexBuf.getData());
  }
}
