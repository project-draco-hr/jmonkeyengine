{
  if (verboseLogging)   logger.info("setVertexAttrib_Array(" + vb + ", "+ idb+ ")");
  if (vb.getBufferType() == VertexBuffer.Type.Index)   throw new IllegalArgumentException("Index buffers not allowed to be set to vertex attrib");
  int programId=context.boundShaderProgram;
  if (programId > 0) {
    VertexBuffer[] attribs=context.boundAttribs;
    Attribute attrib=boundShader.getAttribute(vb.getBufferType().name());
    int loc=attrib.getLocation();
    if (loc == -1) {
      if (verboseLogging)       logger.warning("attribute is invalid in shader: [" + vb.getBufferType().name() + "]");
      return;
    }
 else     if (loc == -2) {
      String attributeName="in" + vb.getBufferType().name();
      if (verboseLogging)       logger.info("GLES20.glGetAttribLocation(" + programId + ", "+ attributeName+ ")");
      loc=GLES20.glGetAttribLocation(programId,attributeName);
      if (loc < 0) {
        attrib.setLocation(-1);
        if (verboseLogging)         logger.warning("attribute is invalid in shader: [" + vb.getBufferType().name() + "]");
        return;
      }
 else {
        attrib.setLocation(loc);
      }
    }
    if ((attribs[loc] != vb) || vb.isUpdateNeeded()) {
      VertexBuffer avb=idb != null ? idb : vb;
      avb.getData().clear();
      avb.getData().position(vb.getOffset());
      if (verboseLogging)       logger.info("GLES20.glVertexAttribPointer(" + "location=" + loc + ", "+ "numComponents="+ vb.getNumComponents()+ ", "+ "format="+ vb.getFormat()+ ", "+ "isNormalized="+ vb.isNormalized()+ ", "+ "stride="+ vb.getStride()+ ", "+ "data.capacity="+ avb.getData().capacity()+ ")");
      GLES20.glVertexAttribPointer(loc,vb.getNumComponents(),convertFormat(vb.getFormat()),vb.isNormalized(),vb.getStride(),avb.getData());
      checkGLError();
      GLES20.glEnableVertexAttribArray(loc);
      attribs[loc]=vb;
    }
  }
 else {
    throw new IllegalStateException("Cannot render mesh without shader bound");
  }
}
