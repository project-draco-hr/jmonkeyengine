{
  if (vb.getBufferType() == VertexBuffer.Type.Index) {
    throw new IllegalArgumentException("Index buffers not allowed to be set to vertex attrib");
  }
  int programId=context.boundShaderProgram;
  if (programId > 0) {
    VertexBuffer[] attribs=context.boundAttribs;
    Attribute attrib=boundShader.getAttribute(vb.getBufferType());
    int loc=attrib.getLocation();
    if (loc == -1) {
      return;
    }
 else     if (loc == -2) {
      String attributeName="in" + vb.getBufferType().name();
      loc=GLES20.glGetAttribLocation(programId,attributeName);
      RendererUtil.checkGLError();
      if (loc < 0) {
        attrib.setLocation(-1);
        return;
      }
 else {
        attrib.setLocation(loc);
      }
    }
    if ((attribs[loc] != vb) || vb.isUpdateNeeded()) {
      VertexBuffer avb=idb != null ? idb : vb;
      avb.getData().rewind();
      avb.getData().position(vb.getOffset());
      GLES20.glVertexAttribPointer(loc,vb.getNumComponents(),convertVertexBufferFormat(vb.getFormat()),vb.isNormalized(),vb.getStride(),avb.getData());
      RendererUtil.checkGLError();
      GLES20.glEnableVertexAttribArray(loc);
      RendererUtil.checkGLError();
      attribs[loc]=vb;
    }
  }
 else {
    throw new IllegalStateException("Cannot render mesh without shader bound");
  }
}
