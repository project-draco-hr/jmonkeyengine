{
  int texId=tex.getId();
  GL gl=GLContext.getCurrentGL();
  if (texId == -1) {
    gl.glGenTextures(1,intBuf1);
    texId=intBuf1.get(0);
    tex.setId(texId);
    objManager.registerForCleanup(tex);
  }
  int target=convertTextureType(tex.getType());
  if (context.boundTextures[0] != tex) {
    if (context.boundTextureUnit != 0) {
      setActiveTexture(GL.GL_TEXTURE0);
      context.boundTextureUnit=0;
    }
    bindTexture(target,texId);
    context.boundTextures[0]=tex;
  }
  int minFilter=convertMinFilter(tex.getMinFilter());
  int magFilter=convertMagFilter(tex.getMagFilter());
  gl.glTexParameteri(target,GL.GL_TEXTURE_MIN_FILTER,minFilter);
  gl.glTexParameteri(target,GL.GL_TEXTURE_MAG_FILTER,magFilter);
switch (tex.getType()) {
case ThreeDimensional:
case CubeMap:
    gl.glTexParameteri(target,GL2GL3.GL_TEXTURE_WRAP_R,convertWrapMode(tex.getWrap(WrapAxis.R)));
case TwoDimensional:
  gl.glTexParameteri(target,GL.GL_TEXTURE_WRAP_T,convertWrapMode(tex.getWrap(WrapAxis.T)));
gl.glTexParameteri(target,GL.GL_TEXTURE_WRAP_S,convertWrapMode(tex.getWrap(WrapAxis.S)));
break;
default :
throw new UnsupportedOperationException("Unknown texture type: " + tex.getType());
}
Image img=tex.getImage();
if (img != null) {
boolean generateMips=false;
if (!img.hasMipmaps() && tex.getMinFilter().usesMipMapLevels()) {
if (hardwareMips) {
gl.glTexParameteri(target,GL2ES1.GL_GENERATE_MIPMAP,GL.GL_TRUE);
}
 else {
generateMips=true;
}
}
TextureUtil.uploadTexture(gl,img,tex.getImageDataIndex(),generateMips,powerOf2);
}
tex.clearUpdateNeeded();
}
