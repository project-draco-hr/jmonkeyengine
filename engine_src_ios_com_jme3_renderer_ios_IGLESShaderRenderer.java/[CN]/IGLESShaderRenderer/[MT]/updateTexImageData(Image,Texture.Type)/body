{
  int texId=img.getId();
  if (texId == -1) {
    JmeIosGLES.glGenTextures(1,intBuf1,0);
    JmeIosGLES.checkGLError();
    texId=intBuf1[0];
    img.setId(texId);
    objManager.registerObject(img);
    statistics.onNewTexture();
  }
  int target=convertTextureType(type);
  if (context.boundTextures[0] != img) {
    if (context.boundTextureUnit != 0) {
      JmeIosGLES.glActiveTexture(JmeIosGLES.GL_TEXTURE0);
      JmeIosGLES.checkGLError();
      context.boundTextureUnit=0;
    }
    JmeIosGLES.glBindTexture(target,texId);
    JmeIosGLES.checkGLError();
    context.boundTextures[0]=img;
  }
  boolean needMips=false;
  if (img.isGeneratedMipmapsRequired()) {
    needMips=true;
    img.setMipmapsGenerated(true);
  }
  if (target == JmeIosGLES.GL_TEXTURE_CUBE_MAP) {
    if (img.getWidth() > maxCubeTexSize || img.getHeight() > maxCubeTexSize) {
      throw new RendererException("Cannot upload cubemap " + img + ". The maximum supported cubemap resolution is "+ maxCubeTexSize);
    }
  }
 else {
    if (img.getWidth() > maxTexSize || img.getHeight() > maxTexSize) {
      throw new RendererException("Cannot upload texture " + img + ". The maximum supported texture resolution is "+ maxTexSize);
    }
  }
  if (target == JmeIosGLES.GL_TEXTURE_CUBE_MAP) {
    List<ByteBuffer> data=img.getData();
    if (data.size() != 6) {
      throw new UnsupportedOperationException("Invalid texture: " + img + "Cubemap textures must contain 6 data units.");
    }
    for (int i=0; i < 6; i++) {
      TextureUtil.uploadTextureAny(img,JmeIosGLES.GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,i,needMips);
    }
  }
 else {
    TextureUtil.uploadTextureAny(img,target,0,needMips);
  }
  img.clearUpdateNeeded();
}
