{
  byte[] bytes=null;
  TexturePixel[] colors=null;
  ByteBuffer data=image.getData(0);
  data.rewind();
  Format format=image.getFormat();
  DDSTexelData texelData=new DDSTexelData(data.remaining() / (format.getBitsPerPixel() * 2),image.getWidth(),image.getHeight(),format != Format.DXT1);
switch (format) {
case DXT1:
    bytes=new byte[image.getWidth() * image.getHeight() * 4];
  colors=new TexturePixel[]{new TexturePixel(),new TexturePixel(),new TexturePixel(),new TexturePixel()};
while (data.hasRemaining()) {
  short c0=data.getShort();
  short c1=data.getShort();
  int col0=RGB565.RGB565_to_ARGB8(c0);
  int col1=RGB565.RGB565_to_ARGB8(c1);
  colors[0].fromARGB8(col0);
  colors[1].fromARGB8(col1);
  if (col0 > col1) {
    colors[2].fromPixel(colors[0]);
    colors[2].mult(2);
    colors[2].add(colors[1]);
    colors[2].divide(3);
    colors[3].fromPixel(colors[1]);
    colors[3].mult(2);
    colors[3].add(colors[0]);
    colors[3].divide(3);
  }
 else {
    colors[2].fromPixel(colors[0]);
    colors[2].add(colors[1]);
    colors[2].mult(0.5f);
    colors[3].fromARGB8(0);
  }
  int indexes=data.getInt();
  texelData.add(colors,indexes);
}
break;
case DXT3:
bytes=new byte[image.getWidth() * image.getHeight() * 4];
colors=new TexturePixel[]{new TexturePixel(),new TexturePixel(),new TexturePixel(),new TexturePixel()};
while (data.hasRemaining()) {
long alpha=data.getLong();
float[] alphas=new float[16];
long alphasIndex=0;
for (int i=0; i < 16; ++i) {
alphasIndex|=i << i * 4;
byte a=(byte)((alpha >> i * 4 & 0x0F) << 4);
alphas[i]=a >= 0 ? a / 255.0f : 1.0f - ~a / 255.0f;
}
short c0=data.getShort();
short c1=data.getShort();
int col0=RGB565.RGB565_to_ARGB8(c0);
int col1=RGB565.RGB565_to_ARGB8(c1);
colors[0].fromARGB8(col0);
colors[1].fromARGB8(col1);
colors[2].fromPixel(colors[0]);
colors[2].mult(2);
colors[2].add(colors[1]);
colors[2].divide(3);
colors[3].fromPixel(colors[1]);
colors[3].mult(2);
colors[3].add(colors[0]);
colors[3].divide(3);
int indexes=data.getInt();
texelData.add(colors,indexes,alphas,alphasIndex);
}
break;
case DXT5:
bytes=new byte[image.getWidth() * image.getHeight() * 4];
colors=new TexturePixel[]{new TexturePixel(),new TexturePixel(),new TexturePixel(),new TexturePixel()};
float[] alphas=new float[8];
while (data.hasRemaining()) {
alphas[0]=data.get() * 255.0f;
alphas[1]=data.get() * 255.0f;
long alphaIndices=data.get() | data.get() << 8 | data.get() << 16 | data.get() << 24 | data.get() << 32 | data.get() << 40;
if (alphas[0] > alphas[1]) {
alphas[2]=(6 * alphas[0] + alphas[1]) / 7;
alphas[3]=(5 * alphas[0] + 2 * alphas[1]) / 7;
alphas[4]=(4 * alphas[0] + 3 * alphas[1]) / 7;
alphas[5]=(3 * alphas[0] + 4 * alphas[1]) / 7;
alphas[6]=(2 * alphas[0] + 5 * alphas[1]) / 7;
alphas[7]=(alphas[0] + 6 * alphas[1]) / 7;
}
 else {
alphas[2]=(4 * alphas[0] + alphas[1]) * 0.2f;
alphas[3]=(3 * alphas[0] + 2 * alphas[1]) * 0.2f;
alphas[4]=(2 * alphas[0] + 3 * alphas[1]) * 0.2f;
alphas[5]=(alphas[0] + 4 * alphas[1]) * 0.2f;
alphas[6]=0;
alphas[7]=1;
}
short c0=data.getShort();
short c1=data.getShort();
int col0=RGB565.RGB565_to_ARGB8(c0);
int col1=RGB565.RGB565_to_ARGB8(c1);
colors[0].fromARGB8(col0);
colors[1].fromARGB8(col1);
colors[2].fromPixel(colors[0]);
colors[2].mult(2);
colors[2].add(colors[1]);
colors[2].divide(3);
colors[3].fromPixel(colors[1]);
colors[3].mult(2);
colors[3].add(colors[0]);
colors[3].divide(3);
int indexes=data.getInt();
texelData.add(colors,indexes,alphas,alphaIndices);
}
break;
default :
LOGGER.fine("Unsupported decompression format.");
}
if (bytes != null) {
byte[] pixelBytes=new byte[4];
for (int i=0; i < image.getWidth(); ++i) {
for (int j=0; j < image.getHeight(); ++j) {
texelData.getRGBA8(i,j,pixelBytes);
bytes[(j * image.getWidth() + i) * 4]=pixelBytes[0];
bytes[(j * image.getWidth() + i) * 4 + 1]=pixelBytes[1];
bytes[(j * image.getWidth() + i) * 4 + 2]=pixelBytes[2];
bytes[(j * image.getWidth() + i) * 4 + 3]=pixelBytes[3];
}
}
return new Image(Format.RGBA8,image.getWidth(),image.getHeight(),BufferUtils.createByteBuffer(bytes));
}
return image;
}
