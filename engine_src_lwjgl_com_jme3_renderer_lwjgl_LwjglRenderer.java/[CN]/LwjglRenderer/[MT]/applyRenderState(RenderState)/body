{
  if (state.isWireframe() && !context.wireframe) {
    glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);
    context.wireframe=true;
  }
 else   if (!state.isWireframe() && context.wireframe) {
    glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
    context.wireframe=false;
  }
  if (state.isDepthTest() && !context.depthTestEnabled) {
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(convertTestFunction(context.depthFunc));
    context.depthTestEnabled=true;
  }
 else   if (!state.isDepthTest() && context.depthTestEnabled) {
    glDisable(GL_DEPTH_TEST);
    context.depthTestEnabled=false;
  }
  if (state.getDepthFunc() != context.depthFunc) {
    glDepthFunc(convertTestFunction(state.getDepthFunc()));
    context.depthFunc=state.getDepthFunc();
  }
  if (state.isAlphaTest() && context.alphaTestFallOff == 0) {
    glEnable(GL_ALPHA_TEST);
    glAlphaFunc(convertTestFunction(context.alphaFunc),state.getAlphaFallOff());
    context.alphaTestFallOff=state.getAlphaFallOff();
  }
 else   if (!state.isAlphaTest() && context.alphaTestFallOff != 0) {
    glDisable(GL_ALPHA_TEST);
    context.alphaTestFallOff=0;
  }
  if (state.getAlphaFunc() != context.alphaFunc) {
    glAlphaFunc(convertTestFunction(state.getAlphaFunc()),state.getAlphaFallOff());
    context.alphaFunc=state.getAlphaFunc();
  }
  if (state.isDepthWrite() && !context.depthWriteEnabled) {
    glDepthMask(true);
    context.depthWriteEnabled=true;
  }
 else   if (!state.isDepthWrite() && context.depthWriteEnabled) {
    glDepthMask(false);
    context.depthWriteEnabled=false;
  }
  if (state.isColorWrite() && !context.colorWriteEnabled) {
    glColorMask(true,true,true,true);
    context.colorWriteEnabled=true;
  }
 else   if (!state.isColorWrite() && context.colorWriteEnabled) {
    glColorMask(false,false,false,false);
    context.colorWriteEnabled=false;
  }
  if (state.isPointSprite() && !context.pointSprite) {
    if (context.boundTextures[0] != null) {
      if (context.boundTextureUnit != 0) {
        glActiveTexture(GL_TEXTURE0);
        context.boundTextureUnit=0;
      }
      glEnable(GL_POINT_SPRITE);
      glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
    }
    context.pointSprite=true;
  }
 else   if (!state.isPointSprite() && context.pointSprite) {
    if (context.boundTextures[0] != null) {
      if (context.boundTextureUnit != 0) {
        glActiveTexture(GL_TEXTURE0);
        context.boundTextureUnit=0;
      }
      glDisable(GL_POINT_SPRITE);
      glDisable(GL_VERTEX_PROGRAM_POINT_SIZE);
      context.pointSprite=false;
    }
  }
  if (state.isPolyOffset()) {
    if (!context.polyOffsetEnabled) {
      glEnable(GL_POLYGON_OFFSET_FILL);
      glPolygonOffset(state.getPolyOffsetFactor(),state.getPolyOffsetUnits());
      context.polyOffsetEnabled=true;
      context.polyOffsetFactor=state.getPolyOffsetFactor();
      context.polyOffsetUnits=state.getPolyOffsetUnits();
    }
 else {
      if (state.getPolyOffsetFactor() != context.polyOffsetFactor || state.getPolyOffsetUnits() != context.polyOffsetUnits) {
        glPolygonOffset(state.getPolyOffsetFactor(),state.getPolyOffsetUnits());
        context.polyOffsetFactor=state.getPolyOffsetFactor();
        context.polyOffsetUnits=state.getPolyOffsetUnits();
      }
    }
  }
 else {
    if (context.polyOffsetEnabled) {
      glDisable(GL_POLYGON_OFFSET_FILL);
      context.polyOffsetEnabled=false;
      context.polyOffsetFactor=0;
      context.polyOffsetUnits=0;
    }
  }
  if (state.getFaceCullMode() != context.cullMode) {
    if (state.getFaceCullMode() == RenderState.FaceCullMode.Off) {
      glDisable(GL_CULL_FACE);
    }
 else {
      glEnable(GL_CULL_FACE);
    }
switch (state.getFaceCullMode()) {
case Off:
      break;
case Back:
    glCullFace(GL_BACK);
  break;
case Front:
glCullFace(GL_FRONT);
break;
case FrontAndBack:
glCullFace(GL_FRONT_AND_BACK);
break;
default :
throw new UnsupportedOperationException("Unrecognized face cull mode: " + state.getFaceCullMode());
}
context.cullMode=state.getFaceCullMode();
}
if (state.getBlendMode() != context.blendMode) {
if (state.getBlendMode() == RenderState.BlendMode.Off) {
glDisable(GL_BLEND);
}
 else {
glEnable(GL_BLEND);
switch (state.getBlendMode()) {
case Off:
break;
case Additive:
glBlendFunc(GL_ONE,GL_ONE);
break;
case AlphaAdditive:
glBlendFunc(GL_SRC_ALPHA,GL_ONE);
break;
case Color:
glBlendFunc(GL_ONE,GL_ONE_MINUS_SRC_COLOR);
break;
case Alpha:
glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
break;
case PremultAlpha:
glBlendFunc(GL_ONE,GL_ONE_MINUS_SRC_ALPHA);
break;
case Modulate:
glBlendFunc(GL_DST_COLOR,GL_ZERO);
break;
case ModulateX2:
glBlendFunc(GL_DST_COLOR,GL_SRC_COLOR);
break;
default :
throw new UnsupportedOperationException("Unrecognized blend mode: " + state.getBlendMode());
}
}
context.blendMode=state.getBlendMode();
}
if (context.stencilTest != state.isStencilTest() || context.frontStencilStencilFailOperation != state.getFrontStencilStencilFailOperation() || context.frontStencilDepthFailOperation != state.getFrontStencilDepthFailOperation() || context.frontStencilDepthPassOperation != state.getFrontStencilDepthPassOperation() || context.backStencilStencilFailOperation != state.getBackStencilStencilFailOperation() || context.backStencilDepthFailOperation != state.getBackStencilDepthFailOperation() || context.backStencilDepthPassOperation != state.getBackStencilDepthPassOperation() || context.frontStencilFunction != state.getFrontStencilFunction() || context.backStencilFunction != state.getBackStencilFunction()) {
context.frontStencilStencilFailOperation=state.getFrontStencilStencilFailOperation();
context.frontStencilDepthFailOperation=state.getFrontStencilDepthFailOperation();
context.frontStencilDepthPassOperation=state.getFrontStencilDepthPassOperation();
context.backStencilStencilFailOperation=state.getBackStencilStencilFailOperation();
context.backStencilDepthFailOperation=state.getBackStencilDepthFailOperation();
context.backStencilDepthPassOperation=state.getBackStencilDepthPassOperation();
context.frontStencilFunction=state.getFrontStencilFunction();
context.backStencilFunction=state.getBackStencilFunction();
if (state.isStencilTest()) {
glEnable(GL_STENCIL_TEST);
glStencilOpSeparate(GL_FRONT,convertStencilOperation(state.getFrontStencilStencilFailOperation()),convertStencilOperation(state.getFrontStencilDepthFailOperation()),convertStencilOperation(state.getFrontStencilDepthPassOperation()));
glStencilOpSeparate(GL_BACK,convertStencilOperation(state.getBackStencilStencilFailOperation()),convertStencilOperation(state.getBackStencilDepthFailOperation()),convertStencilOperation(state.getBackStencilDepthPassOperation()));
glStencilFuncSeparate(GL_FRONT,convertTestFunction(state.getFrontStencilFunction()),0,Integer.MAX_VALUE);
glStencilFuncSeparate(GL_BACK,convertTestFunction(state.getBackStencilFunction()),0,Integer.MAX_VALUE);
}
 else {
glDisable(GL_STENCIL_TEST);
}
}
}
