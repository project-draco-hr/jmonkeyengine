{
  SocketChannel socketChannel=(SocketChannel)channel;
  if (socketChannel == null) {
    log.log(Level.WARNING,"[{0}][TCP] Connection was closed before we could read.",label);
    return;
  }
  int read=-1;
  readBuffer.compact();
  try {
    read=socketChannel.read(readBuffer);
  }
 catch (  IOException ioe) {
    socketChannel.keyFor(selector).cancel();
    if (serverSocketChannel != null) {
      log.log(Level.WARNING,"[{0}][TCP] Connection was forcibly closed before we could read. Disconnected client.",label);
      addToDisconnectionQueue((Client)socketChannel.keyFor(selector).attachment());
    }
 else {
      log.log(Level.WARNING,"[{0}][TCP] Server forcibly closed connection. Disconnected.",label);
      fireClientDisconnected(null);
    }
  }
  if (read != -1) {
    log.log(Level.FINE,"[{1}][TCP] Read {0} bytes.",new Object[]{read,label});
  }
  readBuffer.flip();
  if (read == -1) {
    socketChannel.keyFor(selector).cancel();
    if (serverSocketChannel != null) {
      log.log(Level.WARNING,"[{0}][TCP] Connection was closed before we could read. Disconnected client.",label);
      addToDisconnectionQueue((Client)socketChannel.keyFor(selector).attachment());
    }
 else {
      log.log(Level.WARNING,"[{0}][TCP] Server closed connection. Disconnected.",label);
      fireClientDisconnected(null);
    }
    return;
  }
  while (true) {
    try {
      if (objectLength == 0) {
        objectLength=readBuffer.getShort();
      }
      int pos=readBuffer.position();
      int oldLimit=readBuffer.limit();
      int dataLength=objectLength;
      if (dataLength > 0 && readBuffer.remaining() >= dataLength) {
        if (pos + dataLength + 2 > readBuffer.capacity()) {
          readBuffer.limit(readBuffer.capacity());
        }
 else {
          readBuffer.limit(pos + dataLength + 2);
        }
        Object obj=Serializer.readClassAndObject(readBuffer);
        readBuffer.limit(oldLimit);
        objectLength=0;
        if (obj != null) {
          if (obj instanceof Message) {
            Message message=(Message)obj;
            Object attachment=socketChannel.keyFor(selector).attachment();
            if (attachment instanceof Client)             message.setClient((Client)attachment);
            message.setConnection(this);
            this.fireMessageReceived(message);
          }
 else {
            this.fireObjectReceived(obj);
          }
          log.log(Level.FINEST,"[{0}][TCP] Read full object: {1}",new Object[]{label,obj});
        }
      }
 else       if (dataLength > readBuffer.remaining()) {
        readBuffer.compact();
        int bytesRead=socketChannel.read(readBuffer);
        log.log(Level.FINEST,"[{0}][TCP] Object won't fit in buffer, so read {1} more bytes in a compacted buffer.",new Object[]{label,bytesRead});
        readBuffer.flip();
      }
 else {
        objectLength=dataLength;
      }
    }
 catch (    BufferUnderflowException someEx) {
      log.log(Level.FINEST,"[{0}][TCP] Done reading messages.",new Object[]{label});
      break;
    }
  }
}
