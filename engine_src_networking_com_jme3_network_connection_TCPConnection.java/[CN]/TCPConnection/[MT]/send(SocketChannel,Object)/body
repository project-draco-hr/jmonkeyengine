{
  try {
synchronized (writeLock) {
      tempWriteBuffer.clear();
      tempWriteBuffer.position(4);
      Serializer.writeClassAndObject(tempWriteBuffer,object);
      tempWriteBuffer.flip();
      int dataLength=tempWriteBuffer.limit() - 4;
      tempWriteBuffer.position(0);
      tempWriteBuffer.putInt(dataLength);
      tempWriteBuffer.position(0);
      if (dataLength > writeBuffer.capacity()) {
        log.log(Level.WARNING,"[{0}][TCP] Message too big for buffer. Discarded.",label);
        return;
      }
      if (writeBuffer.position() > 0) {
        try {
          writeBuffer.put(tempWriteBuffer);
        }
 catch (        BufferOverflowException boe) {
          log.log(Level.WARNING,"[{0}][TCP] Buffer overflow occurred while appending data to be sent later. " + "Cleared the buffer, so some data may be lost.",label);
          writeBuffer.clear();
          while (tempWriteBuffer.hasRemaining()) {
            if (channel.write(tempWriteBuffer) == 0)             break;
          }
        }
      }
 else {
        int writeLength=0;
        while (tempWriteBuffer.hasRemaining()) {
          int wrote=channel.write(tempWriteBuffer);
          writeLength+=wrote;
          if (wrote == 0) {
            break;
          }
        }
        log.log(Level.FINE,"[{1}][TCP] Wrote {0} bytes.",new Object[]{writeLength,label});
        try {
          if (writeBuffer.hasRemaining()) {
            writeBuffer.put(tempWriteBuffer);
            channel.keyFor(selector).interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
          }
 else {
            if (object instanceof Message) {
              this.fireMessageSent((Message)object);
            }
 else {
              this.fireObjectSent(object);
            }
          }
        }
 catch (        BufferOverflowException boe) {
          log.log(Level.WARNING,"[{0}][TCP] Buffer overflow occurred while queuing data to be sent later. " + "Cleared the buffer, so some data may be lost. Please note that this exception occurs rarely, " + "so if this is shown often, please check your message sizes or contact the developer.",label);
          writeBuffer.clear();
        }
      }
    }
  }
 catch (  IOException ioe) {
    Client client;
    if (socketChannel == null) {
      client=((Message)object).getClient();
    }
 else {
      client=(Client)socketChannel.keyFor(selector).attachment();
    }
    if (client != null) {
      addToDisconnectionQueue(client);
      log.log(Level.WARNING,"[{0}][TCP] Disconnected {1} because an error occurred: {2}.",new Object[]{label,client,ioe.getMessage()});
      return;
    }
    throw ioe;
  }
}
