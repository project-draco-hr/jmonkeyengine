{
  Object loadedResult=blenderContext.getLoadedFeature(objectStructure.getOldMemoryAddress(),LoadedFeatureDataType.LOADED_FEATURE);
  if (loadedResult != null) {
    return loadedResult;
  }
  blenderContext.pushParent(objectStructure);
  int type=((Number)objectStructure.getFieldValue("type")).intValue();
  String name=objectStructure.getName();
  LOGGER.log(Level.INFO,"Loading obejct: {0}",name);
  int restrictflag=((Number)objectStructure.getFieldValue("restrictflag")).intValue();
  boolean visible=(restrictflag & 0x01) != 0;
  Object result=null;
  Pointer pParent=(Pointer)objectStructure.getFieldValue("parent");
  Object parent=blenderContext.getLoadedFeature(pParent.getOldMemoryAddress(),LoadedFeatureDataType.LOADED_FEATURE);
  if (parent == null && pParent.isNotNull()) {
    Structure parentStructure=pParent.fetchData(blenderContext.getInputStream()).get(0);
    parent=this.toObject(parentStructure,blenderContext);
  }
  Transform t=this.getTransformation(objectStructure,blenderContext);
  try {
switch (type) {
case OBJECT_TYPE_EMPTY:
      LOGGER.log(Level.INFO,"Importing empty.");
    Node empty=new Node(name);
  empty.setLocalTransform(t);
if (parent instanceof Node) {
  ((Node)parent).attachChild(empty);
}
empty.updateModelBound();
result=empty;
break;
case OBJECT_TYPE_MESH:
LOGGER.log(Level.INFO,"Importing mesh.");
Node node=new Node(name);
node.setCullHint(visible ? CullHint.Always : CullHint.Inherit);
MeshHelper meshHelper=blenderContext.getHelper(MeshHelper.class);
Pointer pMesh=(Pointer)objectStructure.getFieldValue("data");
List<Structure> meshesArray=pMesh.fetchData(blenderContext.getInputStream());
List<Geometry> geometries=meshHelper.toMesh(meshesArray.get(0),blenderContext);
if (geometries != null) {
for (Geometry geometry : geometries) {
node.attachChild(geometry);
}
}
node.setLocalTransform(t);
ModifierHelper modifierHelper=blenderContext.getHelper(ModifierHelper.class);
Collection<Modifier> modifiers=modifierHelper.readModifiers(objectStructure,blenderContext);
for (Modifier modifier : modifiers) {
modifier.apply(node,blenderContext);
}
if (parent instanceof Node) {
((Node)parent).attachChild(node);
}
node.updateModelBound();
result=node;
break;
case OBJECT_TYPE_SURF:
case OBJECT_TYPE_CURVE:
LOGGER.log(Level.INFO,"Importing curve/nurb.");
Pointer pCurve=(Pointer)objectStructure.getFieldValue("data");
if (pCurve.isNotNull()) {
CurvesHelper curvesHelper=blenderContext.getHelper(CurvesHelper.class);
Structure curveData=pCurve.fetchData(blenderContext.getInputStream()).get(0);
List<Geometry> curves=curvesHelper.toCurve(curveData,blenderContext);
result=new Node(name);
for (Geometry curve : curves) {
((Node)result).attachChild(curve);
}
((Node)result).setLocalTransform(t);
}
break;
case OBJECT_TYPE_LAMP:
LOGGER.log(Level.INFO,"Importing lamp.");
Pointer pLamp=(Pointer)objectStructure.getFieldValue("data");
if (pLamp.isNotNull()) {
LightHelper lightHelper=blenderContext.getHelper(LightHelper.class);
List<Structure> lampsArray=pLamp.fetchData(blenderContext.getInputStream());
Light light=lightHelper.toLight(lampsArray.get(0),blenderContext);
if (light != null) {
light.setName(name);
}
if (light instanceof PointLight) {
((PointLight)light).setPosition(t.getTranslation());
}
 else if (light instanceof DirectionalLight) {
Quaternion quaternion=t.getRotation();
Vector3f[] axes=new Vector3f[3];
quaternion.toAxes(axes);
((DirectionalLight)light).setDirection(axes[2].negate());
}
 else if (light instanceof SpotLight) {
((SpotLight)light).setPosition(t.getTranslation());
Quaternion quaternion=t.getRotation();
Vector3f[] axes=new Vector3f[3];
quaternion.toAxes(axes);
((SpotLight)light).setDirection(axes[2].negate());
}
 else {
LOGGER.log(Level.WARNING,"Unknown type of light: {0}",light);
}
result=light;
}
break;
case OBJECT_TYPE_CAMERA:
Pointer pCamera=(Pointer)objectStructure.getFieldValue("data");
if (pCamera.isNotNull()) {
CameraHelper cameraHelper=blenderContext.getHelper(CameraHelper.class);
List<Structure> camerasArray=pCamera.fetchData(blenderContext.getInputStream());
Camera camera=cameraHelper.toCamera(camerasArray.get(0));
camera.setLocation(t.getTranslation());
camera.setRotation(t.getRotation());
result=camera;
}
break;
case OBJECT_TYPE_ARMATURE:
Node armature=new Node(name);
armature.setLocalTransform(t);
if (parent instanceof Node) {
((Node)parent).attachChild(armature);
}
armature.updateModelBound();
result=armature;
break;
default :
LOGGER.log(Level.WARNING,"Unknown object type: {0}",type);
}
}
  finally {
blenderContext.popParent();
}
if (result != null) {
blenderContext.addLoadedFeatures(objectStructure.getOldMemoryAddress(),name,objectStructure,result);
ConstraintHelper constraintHelper=blenderContext.getHelper(ConstraintHelper.class);
constraintHelper.loadConstraints(objectStructure,blenderContext);
List<Constraint> objectConstraints=blenderContext.getConstraints(objectStructure.getOldMemoryAddress());
if (objectConstraints != null) {
for (Constraint objectConstraint : objectConstraints) {
objectConstraint.bake();
}
}
Properties properties=this.loadProperties(objectStructure,blenderContext);
if (result instanceof Spatial && properties != null && properties.getValue() != null) {
((Spatial)result).setUserData("properties",properties);
}
}
return result;
}
