{
  LOGGER.fine("Reading BMesh.");
  Pointer pMLoop=(Pointer)meshStructure.getFieldValue("mloop");
  Pointer pMPoly=(Pointer)meshStructure.getFieldValue("mpoly");
  Pointer pMEdge=(Pointer)meshStructure.getFieldValue("medge");
  Map<String,Vector2f[]> uvCoordinatesForFace=new HashMap<String,Vector2f[]>();
  if (pMPoly.isNotNull() && pMLoop.isNotNull() && pMEdge.isNotNull()) {
    Map<String,List<Vector2f>> uvs=this.loadUVCoordinates(meshStructure,true,blenderContext);
    int faceIndex=0;
    List<Structure> polys=pMPoly.fetchData(blenderContext.getInputStream());
    List<Structure> loops=pMLoop.fetchData(blenderContext.getInputStream());
    for (    Structure poly : polys) {
      int materialNumber=((Number)poly.getFieldValue("mat_nr")).intValue();
      int loopStart=((Number)poly.getFieldValue("loopstart")).intValue();
      int totLoop=((Number)poly.getFieldValue("totloop")).intValue();
      boolean smooth=(((Number)poly.getFieldValue("flag")).byteValue() & 0x01) != 0x00;
      int[] vertexIndexes=new int[totLoop];
      for (int i=loopStart; i < loopStart + totLoop; ++i) {
        vertexIndexes[i - loopStart]=((Number)loops.get(i).getFieldValue("v")).intValue();
      }
      int i=0;
      while (i < totLoop - 2) {
        int v1=vertexIndexes[0];
        int v2=vertexIndexes[i + 1];
        int v3=vertexIndexes[i + 2];
        if (uvs != null) {
          for (          Entry<String,List<Vector2f>> entry : uvs.entrySet()) {
            Vector2f[] uvCoordsForASingleFace=new Vector2f[3];
            uvCoordsForASingleFace[0]=entry.getValue().get(loopStart);
            uvCoordsForASingleFace[1]=entry.getValue().get(loopStart + i + 1);
            uvCoordsForASingleFace[2]=entry.getValue().get(loopStart + i + 2);
            uvCoordinatesForFace.put(entry.getKey(),uvCoordsForASingleFace);
          }
        }
        meshBuilder.appendFace(v1,v2,v3,smooth,materialNumber,uvs == null ? null : uvCoordinatesForFace,false,faceIndex);
        uvCoordinatesForFace.clear();
        ++i;
      }
      ++faceIndex;
    }
  }
}
