{
  LOGGER.log(Level.INFO,"Loading material.");
  if (structure == null) {
    return blenderContext.getDefaultMaterial();
  }
  Material result=(Material)blenderContext.getLoadedFeature(structure.getOldMemoryAddress(),LoadedFeatureDataType.LOADED_FEATURE);
  if (result != null) {
    return result;
  }
  MaterialContext materialContext=new MaterialContext(structure,blenderContext);
  LOGGER.log(Level.INFO,"Material's name: {0}",materialContext.name);
  if (materialContext.textures.size() > 0) {
    LOGGER.log(Level.WARNING,"Attetion! Many textures found for material: {0}. Only the first of each supported mapping types will be used!",materialContext.name);
  }
  Type colorTextureType=null;
  Map<String,Texture> texturesMap=new HashMap<String,Texture>();
  TextureHelper textureHelper=blenderContext.getHelper(TextureHelper.class);
  for (  Entry<Number,Texture> textureEntry : materialContext.loadedTextures.entrySet()) {
    int mapto=textureEntry.getKey().intValue();
    Texture texture=textureEntry.getValue();
    if ((mapto & MaterialContext.MTEX_COL) != 0) {
      colorTextureType=texture.getType();
      if (materialContext.shadeless) {
        texturesMap.put(colorTextureType == Type.ThreeDimensional ? TEXTURE_TYPE_3D : TEXTURE_TYPE_COLOR,texture);
      }
 else {
        texturesMap.put(colorTextureType == Type.ThreeDimensional ? TEXTURE_TYPE_3D : TEXTURE_TYPE_DIFFUSE,texture);
      }
    }
    if (texture.getType() == Type.TwoDimensional) {
      if ((mapto & MaterialContext.MTEX_NOR) != 0 && !materialContext.shadeless) {
        Structure mTex=materialContext.getMTex(texture);
        Texture normalMapTexture=textureHelper.convertToNormalMapTexture(texture,((Number)mTex.getFieldValue("norfac")).floatValue());
        texturesMap.put(TEXTURE_TYPE_NORMAL,normalMapTexture);
      }
      if ((mapto & MaterialContext.MTEX_EMIT) != 0) {
        texturesMap.put(TEXTURE_TYPE_GLOW,texture);
      }
      if ((mapto & MaterialContext.MTEX_SPEC) != 0 && !materialContext.shadeless) {
        texturesMap.put(TEXTURE_TYPE_SPECULAR,texture);
      }
      if ((mapto & MaterialContext.MTEX_ALPHA) != 0 && !materialContext.shadeless) {
        texturesMap.put(TEXTURE_TYPE_ALPHA,texture);
      }
    }
  }
  if (colorTextureType == Type.ThreeDimensional) {
    result=new Material(blenderContext.getAssetManager(),"jme3test/texture/tex3D.j3md");
  }
 else {
    if (materialContext.shadeless) {
      result=new Material(blenderContext.getAssetManager(),"Common/MatDefs/Misc/Unshaded.j3md");
    }
 else {
      result=new Material(blenderContext.getAssetManager(),"Common/MatDefs/Light/Lighting.j3md");
      result.setBoolean("UseMaterialColors",Boolean.TRUE);
      result.setBoolean("Minnaert",materialContext.diffuseShader == DiffuseShader.MINNAERT);
      if (!materialContext.transparent) {
        materialContext.diffuseColor.a=1;
      }
      result.setColor("Diffuse",materialContext.diffuseColor);
      result.setBoolean("WardIso",materialContext.specularShader == SpecularShader.WARDISO);
      result.setColor("Specular",materialContext.specularColor);
      result.setColor("Ambient",materialContext.ambientColor);
      result.setFloat("Shininess",materialContext.shininess);
    }
    if (materialContext.vertexColor) {
      result.setBoolean(materialContext.shadeless ? "VertexColor" : "UseVertexColor",true);
    }
  }
  for (  Entry<String,Texture> textureEntry : texturesMap.entrySet()) {
    result.setTexture(textureEntry.getKey(),textureEntry.getValue());
  }
  result.getAdditionalRenderState().setFaceCullMode(faceCullMode);
  if (materialContext.transparent) {
    result.setTransparent(true);
    result.getAdditionalRenderState().setBlendMode(BlendMode.Alpha);
  }
  blenderContext.setMaterialContext(result,materialContext);
  blenderContext.addLoadedFeatures(structure.getOldMemoryAddress(),structure.getName(),structure,result);
  return result;
}
