{
  LOGGER.log(Level.INFO,"Loading material.");
  if (structure == null) {
    return dataRepository.getDefaultMaterial();
  }
  Material result=(Material)dataRepository.getLoadedFeature(structure.getOldMemoryAddress(),LoadedFeatureDataType.LOADED_FEATURE);
  if (result != null) {
    return result;
  }
  MaterialContext materialContext=new MaterialContext(structure,dataRepository);
  LOGGER.log(Level.INFO,"Material's name: {0}",materialContext.name);
  Map<String,Texture> texturesMap=new HashMap<String,Texture>();
  Type firstTextureType=null;
  if ((dataRepository.getBlenderKey().getFeaturesToLoad() & FeaturesToLoad.TEXTURES) != 0) {
    TextureHelper textureHelper=dataRepository.getHelper(TextureHelper.class);
    for (int i=0; i < materialContext.texturesCount; ++i) {
      Structure mtex=materialContext.mTexs.get(i);
      int texflag=((Number)mtex.getFieldValue("texflag")).intValue();
      boolean negateTexture=(texflag & 0x04) == 0;
      int mapto=((Number)mtex.getFieldValue("mapto")).intValue();
      if (mapto != 0) {
        Structure tex=materialContext.textures.get(i);
        Texture texture=textureHelper.getTexture(tex,dataRepository);
        if (texture != null) {
          if (firstTextureType == null) {
            firstTextureType=texture.getType();
          }
 else           if (firstTextureType != texture.getType()) {
            LOGGER.warning("The texture with the name: " + texture.getName() + " is of different type than the first applied texture! It will not be applied!");
            continue;
          }
          texture.setMinFilter(MinFilter.Trilinear);
          if ((mapto & 0x01) != 0) {
            int blendType=((Number)mtex.getFieldValue("blendtype")).intValue();
            float[] color=new float[]{((Number)mtex.getFieldValue("r")).floatValue(),((Number)mtex.getFieldValue("g")).floatValue(),((Number)mtex.getFieldValue("b")).floatValue()};
            float colfac=((Number)mtex.getFieldValue("colfac")).floatValue();
            texture=textureHelper.blendTexture(new float[]{1,1,1},texture,color,colfac,blendType,negateTexture,dataRepository);
            texture.setWrap(WrapMode.Repeat);
            if (materialContext.shadeless) {
              texturesMap.put(firstTextureType == Type.ThreeDimensional ? TEXTURE_TYPE_3D : TEXTURE_TYPE_COLOR,texture);
            }
 else {
              texturesMap.put(firstTextureType == Type.ThreeDimensional ? TEXTURE_TYPE_3D : TEXTURE_TYPE_DIFFUSE,texture);
            }
          }
          if (firstTextureType == Type.TwoDimensional) {
            if ((mapto & 0x02) != 0 && !materialContext.shadeless) {
              Texture normalMapTexture;
              if (texture.getKey() instanceof GeneratedTextureKey) {
                normalMapTexture=textureHelper.convertToNormalMapTexture(texture,((Number)mtex.getFieldValue("norfac")).floatValue());
                normalMapTexture.setMinFilter(MinFilter.Trilinear);
              }
 else {
                normalMapTexture=texture;
              }
              texturesMap.put(TEXTURE_TYPE_NORMAL,normalMapTexture);
            }
            if ((mapto & 0x04) != 0 && !materialContext.shadeless) {
              texturesMap.put(TEXTURE_TYPE_SPECULAR,texture);
            }
            if ((mapto & 0x40) != 0) {
              texturesMap.put(TEXTURE_TYPE_GLOW,texture);
            }
            if ((mapto & 0x80) != 0 && !materialContext.shadeless) {
              texturesMap.put(TEXTURE_TYPE_ALPHA,texture);
            }
          }
 else {
            LOGGER.warning("The following mappings: [Nor, Spec, Alpha] are available for 2D textures only!");
          }
        }
 else {
          LOGGER.log(Level.WARNING,"Texture not found!");
        }
      }
    }
  }
  if (firstTextureType == Type.ThreeDimensional) {
    result=new Material(dataRepository.getAssetManager(),"jme3test/texture/tex3D.j3md");
  }
 else {
    if (materialContext.shadeless) {
      result=new Material(dataRepository.getAssetManager(),"Common/MatDefs/Misc/Unshaded.j3md");
    }
 else {
      result=new Material(dataRepository.getAssetManager(),"Common/MatDefs/Light/Lighting.j3md");
    }
    if (materialContext.vertexColor) {
      result.setBoolean(materialContext.shadeless ? "VertexColor" : "UseVertexColor",true);
    }
    ColorRGBA diffuseColor=null;
    if (materialContext.shadeless) {
      diffuseColor=ColorRGBA.White.clone();
    }
 else {
      result.setBoolean("UseMaterialColors",Boolean.TRUE);
      DiffuseShader diffuseShader=this.getDiffuseShader(structure);
      result.setBoolean("Minnaert",diffuseShader == DiffuseShader.MINNAERT);
      diffuseColor=this.getDiffuseColor(structure,diffuseShader);
      if (!materialContext.transparent) {
        diffuseColor.a=1;
      }
      result.setColor("Diffuse",diffuseColor);
      SpecularShader specularShader=this.getSpecularShader(structure);
      result.setBoolean("WardIso",specularShader == SpecularShader.WARDISO);
      result.setColor("Specular",this.getSpecularColor(structure,specularShader));
      result.setColor("Ambient",this.getAmbientColor(structure));
      result.setFloat("Shininess",this.getShininess(structure));
    }
  }
  for (  Entry<String,Texture> textureEntry : texturesMap.entrySet()) {
    result.setTexture(textureEntry.getKey(),textureEntry.getValue());
  }
  result.getAdditionalRenderState().setFaceCullMode(faceCullMode);
  if (materialContext.transparent) {
    result.setTransparent(true);
    result.getAdditionalRenderState().setBlendMode(BlendMode.Alpha);
  }
  dataRepository.setMaterialContext(result,materialContext);
  dataRepository.addLoadedFeatures(structure.getOldMemoryAddress(),structure.getName(),structure,result);
  return result;
}
